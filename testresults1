# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = “affected individual”
1	“affected	“affect	ADJ	PASS	Case=Nom	2	amod	_	_
2	individual”	individual”	NOUN	SG-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2] individual” 2 (1) NOUN root (root_only (rootN_ (MassNP_sg (AdjCN (StrAP "\8220affect") (UseN (StrN "individual\8221"))))) : UDS[1,2]) 1
    [1] “affected 1 (2) ADJ amod (StrAP "\8220affect" : AP[1]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (AdjCN (StrAP "\8220affect") (UseN (StrN "individual\8221")))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is “affect individual”

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (AdjCN (StrAP "\8220affect") (UseN (StrN "individual\8221")))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is “affect individual”

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = individual to whom any personal data affected by a data breach relates
1	individual	individual	ADJ	POS	Degree=Pos	6	amod	_	_
2	to	to	ADP	_	_	3	case	_	_
3	whom	who	PRON	WH-REL-ACC	PronType=Int	1	nmod	_	_
4	any	any	DET	IND	_	6	det	_	_
5	personal	personal	ADJ	POS	Degree=Pos	6	amod	_	_
6	data	data	NOUN	PL-NOM	Number=Sing	0	root	_	_
7	affected	affect	VERB	PASS	Tense=Past|VerbForm=Part|Voice=Pass	6	acl	_	_
8	by	by	ADP	_	_	12	case	_	_
9	a	a	DET	IND-SG	Definite=Ind|PronType=Art	12	det	_	_
10	data	data	NOUN	PL-NOM	Number=Sing	11	compound	_	_
11	breach	breach	NOUN	SG-NOM	Number=Sing	12	compound	_	_
12	relates	relate	NOUN	PL-NOM	Number=Plur	7	obl	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,4,5,6,7,8,9,10,11,12] data 6 (5) NOUN root (root_acl (rootN_ (DetCN_anySg anyPl_Det (AdjCN (PositA personal_A) (AdjCN (PositA individual_A) (UseN data_N))))) (aclPastPart_ (root_obl (rootV_ (PassV_ affect_V)) (obl_ (PrepNP by8agent_Prep (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN (CompoundN data_N breach_N) relate_N))))))) : UDS[1,4,5,6,7,8,9,10,11,12]) 1
    [1] individual 1 (2) ADJ amod (PositA individual_A : AP[1]) 1
        *[2,3] whom 3 (2) PRON nmod (PrepIP to_Prep who_IP : IAdv[2,3]) 1
            [2] to 2 (1) ADP case (to_Prep : Prep[2]) 1
    [4] any 4 (3) DET det (anyPl_Det : Det[4]) 1
    [5] personal 5 (4) ADJ amod (PositA personal_A : AP[5]) 1
    [7,8,9,10,11,12] affected 7 (6) VERB acl (aclPastPart_ (root_obl (rootV_ (PassV_ affect_V)) (obl_ (PrepNP by8agent_Prep (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN (CompoundN data_N breach_N) relate_N)))))) : acl[7,8,9,10,11,12]) 1
        [8,9,10,11,12] relates 12 (11) NOUN obl (obl_ (PrepNP by8agent_Prep (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN (CompoundN data_N breach_N) relate_N)))) : obl[8,9,10,11,12]) 1
            [8] by 8 (7) ADP case (by8agent_Prep : Prep[8]) 1
            [9] a 9 (8) DET det (DetQuant IndefArt NumSg : Det[9]) 1
            [10,11] breach 11 (10) NOUN compound (CompoundN data_N breach_N : N[10,11]) 1
                [10] data 10 (9) NOUN compound (data_N : N[10]) 1

# at, final GF tree, macros expanded:
root_acl (rootN_ (DetCN anySg_Det (AdjCN (PositA personal_A) (AdjCN (PositA individual_A) (UseN data_N))))) (aclUDSpastpart_ (root_obl (rootV_ (PassV affect_V)) (obl_ (PrepNP by8agent_Prep (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN (CompoundN data_N breach_N) relate_N)))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is any personal individual data been affected by a data breach relate

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_acl (rootN_ (DetCN anySg_Det (AdjCN (PositA personal_A) (AdjCN (PositA individual_A) (UseN data_N))))) (aclUDSpastpart_ (root_obl (rootV_ (PassV affect_V)) (obl_ (PrepNP by8agent_Prep (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN (CompoundN data_N breach_N) relate_N)))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is any personal individual data been affected by a data breach relate

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = “data breach”
1	“data	“data	DET	IND-SG	Definite=Ind|PronType=Art	2	det	_	_
2	breach”	breach”	NOUN	SG-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2] breach” 2 (1) NOUN root (root_only (rootN_ (DetCN_theSg (StrThe "\8220data") (UseN (StrN "breach\8221")))) : UDS[1,2]) 1
    [1] “data 1 (2) DET det (StrThe "\8220data" : The[1]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (DetCN the_Det (UseN (StrN "breach\8221"))))

# tc, type checking the final GF tree:
unknown words: the_Det
Function the_Det is not in scope


#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (DetCN the_Det (UseN (StrN "breach\8221"))))

# tc, type checking the final GF tree:
unknown words: the_Det
Function the_Det is not in scope


# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = personal data
1	personal	personal	ADJ	POS	Degree=Pos	2	amod	_	_
2	data	data	NOUN	PL-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2] data 2 (1) NOUN root (root_only (rootN_ (MassNP_sg (AdjCN (PositA personal_A) (UseN data_N)))) : UDS[1,2]) 1
    [1] personal 1 (2) ADJ amod (PositA personal_A : AP[1]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (AdjCN (PositA personal_A) (UseN data_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is personal data

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (AdjCN (PositA personal_A) (UseN data_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is personal data

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = the unauthorised access , collection , use , disclosure , copying , modification [ or ] disposal [ of ] personal data
1	the	the	DET	DEF	Definite=Def|PronType=Art	3	det	_	_
2	unauthorised	unauthorised	ADJ	POS	Degree=Pos	3	amod	_	_
3	access	access	NOUN	SG-NOM	Number=Sing	0	root	_	_
4	,	,	PUNCT	Comma	_	3	punct	_	_
5	collection	collection	NOUN	SG-NOM	Number=Sing	3	conj	_	_
6	,	,	PUNCT	Comma	_	5	punct	_	_
7	use	use	NOUN	SG-NOM	Number=Sing	3	conj	_	_
8	,	,	PUNCT	Comma	_	7	punct	_	_
9	disclosure	disclosure	NOUN	SG-NOM	Number=Sing	3	conj	_	_
10	,	,	PUNCT	Comma	_	11	punct	_	_
11	copying	copy	VERB	ING	Tense=Pres|VerbForm=Part	3	acl	_	_
12	,	,	PUNCT	Comma	_	13	punct	_	_
13	modification	modification	NOUN	SG-NOM	Number=Sing	11	conj	_	_
14	[	[	PUNCT	Period	_	17	punct	_	_
15	or	or	CCONJ	_	_	17	cc	_	_
16	]	]	PUNCT	Period	_	17	punct	_	_
17	disposal	disposal	NOUN	SG-NOM	Number=Sing	11	conj	_	_
18	[	[	PUNCT	Period	_	22	punct	_	_
19	of	of	ADP	_	_	22	case	_	_
20	]	]	PUNCT	Period	_	19	punct	_	_
21	personal	personal	ADJ	POS	Degree=Pos	22	amod	_	_
22	data	data	NOUN	PL-NOM	Number=Sing	11	conj	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2,3,11] access 3 (2) NOUN root (root_acl (rootN_ (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA unauthorized_A) (UseN access_N)))) (aclUDSgerund_ (root_only (rootV_ (UseV copy_V)))) : UDS[1,2,3,11]) 1
    [1] the 1 (2) DET det (DetQuant DefArt NumSg : Det[1]) 1
    [2] unauthorised 2 (1) ADJ amod (PositA unauthorized_A : AP[2]) 1
    *[4] , 4 (3) PUNCT punct (comma_Conj : Conj[4]) 1
    *[5] collection 5 (4) NOUN conj (root_only (rootN_ (MassNP_sg (UseN collection_N))) : UDS[5]) 1
        *[6] , 6 (5) PUNCT punct (comma_Conj : Conj[6]) 1
    *[7] use 7 (6) NOUN conj (root_only (rootN_ (MassNP_sg (UseN use_N))) : UDS[7]) 1
        *[8] , 8 (7) PUNCT punct (comma_Conj : Conj[8]) 1
    *[9] disclosure 9 (8) NOUN conj (root_only (rootN_ (MassNP_sg (UseN disclosure_N))) : UDS[9]) 1
    [11] copying 11 (10) VERB acl (aclUDSgerund_ (root_only (rootV_ (UseV copy_V))) : acl[11]) 1
        *[10] , 10 (9) PUNCT punct (comma_Conj : Conj[10]) 1
        *[13] modification 13 (12) NOUN conj (root_only (rootN_ (MassNP_sg (UseN modification_N))) : UDS[13]) 1
            *[12] , 12 (11) PUNCT punct (comma_Conj : Conj[12]) 1
        *[15,17] disposal 17 (16) NOUN conj (root_cc (rootN_ (MassNP_sg (UseN disposal_N))) (cc_ or_Conj) : UDS[15,17]) 1
            *[14] [ 14 (13) PUNCT punct (StrComma "[" : Comma[14]) 1
            [15] or 15 (14) CCONJ cc (cc_ or_Conj : cc[15]) 1
            *[16] ] 16 (15) PUNCT punct (StrComma "]" : Comma[16]) 1
        *[18,19,21,22] data 22 (21) NOUN conj (root_only (rootAdv_ (PrepNP of_Prep (MassNP_sg (AdjCN (PositA personal_A) (UseN data_N))))) : UDS[19,21,22]) 1
            *[18] [ 18 (17) PUNCT punct (StrComma "[" : Comma[18]) 1
            [19,20] of 19 (18) ADP case (of_Prep : Prep[19]) 1
                *[20] ] 20 (19) PUNCT punct (StrComma "]" : Comma[20]) 1
            [21] personal 21 (20) ADJ amod (PositA personal_A : AP[21]) 1

# at, final GF tree, macros expanded:
root_acl (rootN_ (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA unauthorized_A) (UseN access_N)))) (aclUDSgerund_ (root_only (rootV_ (UseV copy_V))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is the unauthorized access that copies

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_acl (rootN_ (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA unauthorized_A) (UseN access_N)))) (aclUDSgerund_ (root_only (rootV_ (UseV copy_V))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is the unauthorized access that copies

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = the loss of any storage medium or device on which personal data is stored in circumstances where the unauthorised access , collection , use , disclosure , copying , modification [ or ] disposal of the personal data is likely to occur
1	the	the	DET	DEF	Definite=Def|PronType=Art	2	det	_	_
2	loss	loss	NOUN	SG-NOM	Number=Sing	0	root	_	_
3	of	of	ADP	_	_	6	case	_	_
4	any	any	DET	IND	_	6	det	_	_
5	storage	storage	NOUN	SG-NOM	Number=Sing	6	compound	_	_
6	medium	medium	NOUN	SG-NOM	Number=Sing	2	nmod	_	_
7	or	or	CCONJ	_	_	8	cc	_	_
8	device	device	NOUN	SG-NOM	Number=Sing	6	conj	_	_
9	on	on	ADP	_	_	10	case	_	_
10	which	which	PRON	WH-REL	PronType=Int	14	obl	_	_
11	personal	personal	ADJ	POS	Degree=Pos	12	amod	_	_
12	data	data	NOUN	PL-NOM	Number=Sing	14	nsubj:pass	_	_
13	is	be	AUX	PRES-AUX	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	14	aux:pass	_	_
14	stored	store	VERB	PASS	Tense=Past|VerbForm=Part|Voice=Pass	8	acl:relcl	_	_
15	in	in	ADP	_	_	16	case	_	_
16	circumstances	circumstance	NOUN	PL-NOM	Number=Plur	14	obl	_	_
17	where	where	ADV	WH-REL	PronType=Int	40	advmod	_	_
18	the	the	DET	DEF	Definite=Def|PronType=Art	20	det	_	_
19	unauthorised	unauthorised	ADJ	POS	Degree=Pos	20	amod	_	_
20	access	access	NOUN	SG-NOM	Number=Sing	40	nsubj	_	_
21	,	,	PUNCT	Comma	_	20	punct	_	_
22	collection	collection	NOUN	SG-NOM	Number=Sing	20	conj	_	_
23	,	,	PUNCT	Comma	_	22	punct	_	_
24	use	use	NOUN	SG-NOM	Number=Sing	20	conj	_	_
25	,	,	PUNCT	Comma	_	24	punct	_	_
26	disclosure	disclosure	NOUN	SG-NOM	Number=Sing	20	conj	_	_
27	,	,	PUNCT	Comma	_	28	punct	_	_
28	copying	copy	VERB	ING	Tense=Pres|VerbForm=Part	20	conj	_	_
29	,	,	PUNCT	Comma	_	28	punct	_	_
30	modification	modification	NOUN	SG-NOM	Number=Sing	20	conj	_	_
31	[	[	PUNCT	Period	_	34	punct	_	_
32	or	or	CCONJ	_	_	34	cc	_	_
33	]	]	PUNCT	Period	_	32	punct	_	_
34	disposal	disposal	NOUN	SG-NOM	Number=Sing	20	conj	_	_
35	of	of	ADP	_	_	38	case	_	_
36	the	the	DET	DEF	Definite=Def|PronType=Art	38	det	_	_
37	personal	personal	ADJ	POS	Degree=Pos	38	amod	_	_
38	data	data	NOUN	PL-NOM	Number=Sing	20	nmod	_	_
39	is	be	AUX	PRES	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	40	cop	_	_
40	likely	like	ADJ	POS	Degree=Pos	16	acl:relcl	_	_
41	to	to	PART	_	_	42	mark	_	_
42	occur	occur	VERB	INF	VerbForm=Inf	40	acl	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2,3,4,5,6,7,8] loss 2 (1) NOUN root (root_nmod (rootN_ (DetCN (DetQuant DefArt NumSg) (UseN loss_N))) (nmod_ of_Prep (DetCN_anySg anyPl_Det (CN2_ (UseN (CompoundN storage_N medium_N)) (AndCNPair_ or_Conj (UseN device_N))))) : UDS[1,2,3,4,5,6,7,8]) 1
    [1] the 1 (2) DET det (DetQuant DefArt NumSg : Det[1]) 1
    [3,4,5,6,7,8] medium 6 (5) NOUN nmod (nmod_ of_Prep (DetCN_anySg anyPl_Det (CN2_ (UseN (CompoundN storage_N medium_N)) (AndCNPair_ or_Conj (UseN device_N)))) : nmod[3,4,5,6,7,8]) 1
        [3] of 3 (2) ADP case (of_Prep : Prep[3]) 1
        [4] any 4 (3) DET det (anyPl_Det : Det[4]) 1
        [5] storage 5 (4) NOUN compound (storage_N : N[5]) 1
        [8,11,12,13,14,15,16] device 8 (7) NOUN conj (AndCNPair_ or_Conj (UseN device_N) : Pair_Conj_CN[7,8]) 1
            [7] or 7 (6) CCONJ cc (or_Conj : Conj[7]) 1
            *[11,12,13,14,15,16] stored 14 (13) VERB acl:relcl (root_nsubjPass_auxPass (rootV_ (OblVP_ (PassV_ store_V) (PrepNP in_Prep (DetCN_aPl (UseN circumstance_N))))) (nsubjPass_ (MassNP_sg (AdjCN (PositA personal_A) (UseN data_N)))) be_auxPass : UDS[11,12,13,14,15,16]) 1
                *[9,10] which 10 (9) PRON obl (PrepIP on_Prep (IdetIP (IdetQuant which_IQuant NumSg)) : IAdv[9,10]) 1
                    [9] on 9 (8) ADP case (on_Prep : Prep[9]) 1
                [11,12] data 12 (11) NOUN nsubj:pass (nsubjPass_ (MassNP_sg (AdjCN (PositA personal_A) (UseN data_N))) : nsubjPass[11,12]) 1
                    [11] personal 11 (10) ADJ amod (PositA personal_A : AP[11]) 1
                [13] is 13 (12) AUX aux:pass (be_auxPass : auxPass[13]) 1
                [15,16,18,19,20,32,34,35,36,37,38,39,40] circumstances 16 (15) NOUN obl (PrepNP in_Prep (DetCN_aPl (UseN circumstance_N)) : Adv[15,16]) 1
                    [15] in 15 (14) ADP case (in_Prep : Prep[15]) 1
                    *[18,19,20,32,34,35,36,37,38,39,40] likely 40 (39) ADJ acl:relcl (root_nsubj_cop (rootA_ (PositA like_A)) (nsubj_ (NP2_ (AdvNP (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA unauthorized_A) (UseN access_N))) (PrepNP of_Prep (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA personal_A) (UseN data_N))))) (AndDogPair_ or_Conj (MassNP_sg (UseN disposal_N))))) be_cop : UDS[18,19,20,32,34,35,36,37,38,39,40]) 1
                        *[17] where 17 (16) ADV advmod (where_IAdv : IAdv[17]) 1
                        [18,19,20,30,32,34,35,36,37,38] access 20 (19) NOUN nsubj (nsubj_ (NP2_ (AdvNP (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA unauthorized_A) (UseN access_N))) (PrepNP of_Prep (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA personal_A) (UseN data_N))))) (AndDogPair_ or_Conj (MassNP_sg (UseN disposal_N)))) : nsubj[18,19,20,32,34,35,36,37,38]) 1
                            [18] the 18 (17) DET det (DetQuant DefArt NumSg : Det[18]) 1
                            [19] unauthorised 19 (18) ADJ amod (PositA unauthorized_A : AP[19]) 1
                            *[21] , 21 (20) PUNCT punct (comma_Conj : Conj[21]) 1
                            *[22] collection 22 (21) NOUN conj (root_only (rootN_ (MassNP_sg (UseN collection_N))) : UDS[22]) 1
                                *[23] , 23 (22) PUNCT punct (comma_Conj : Conj[23]) 1
                            *[24] use 24 (23) NOUN conj (root_only (rootN_ (MassNP_sg (UseN use_N))) : UDS[24]) 1
                                *[25] , 25 (24) PUNCT punct (comma_Conj : Conj[25]) 1
                            *[26] disclosure 26 (25) NOUN conj (root_only (rootN_ (MassNP_sg (UseN disclosure_N))) : UDS[26]) 1
                            *[28] copying 28 (27) VERB conj (root_only (rootV_ (UseV copy_V)) : UDS[28]) 1
                                *[27] , 27 (26) PUNCT punct (comma_Conj : Conj[27]) 1
                                *[29] , 29 (28) PUNCT punct (comma_Conj : Conj[29]) 1
                            *[30] modification 30 (29) NOUN conj (root_only (rootN_ (MassNP_sg (UseN modification_N))) : UDS[30]) 1
                            [32,34] disposal 34 (33) NOUN conj (AndDogPair_ or_Conj (MassNP_sg (UseN disposal_N)) : Pair_Conj_NP[32,34]) 1
                                *[31] [ 31 (30) PUNCT punct (StrComma "[" : Comma[31]) 1
                                [32] or 32 (31) CCONJ cc (or_Conj : Conj[32]) 1
                                    *[33] ] 33 (32) PUNCT punct (StrComma "]" : Comma[33]) 1
                            [35,36,37,38] data 38 (37) NOUN nmod (PrepNP of_Prep (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA personal_A) (UseN data_N))) : Adv[35,36,37,38]) 1
                                [35] of 35 (34) ADP case (of_Prep : Prep[35]) 1
                                [36] the 36 (35) DET det (DetQuant DefArt NumSg : Det[36]) 1
                                [37] personal 37 (36) ADJ amod (PositA personal_A : AP[37]) 1
                        [39] is 39 (38) AUX cop (be_cop : cop[39]) 1
                        *[42] occur 42 (41) VERB acl (root_only (rootV_ (UseV occur_V)) : UDS[42]) 1
                            *[41] to 41 (40) PART mark (root_only (rootAdv_ to_Adv) : UDS[41]) 1

# at, final GF tree, macros expanded:
root_nmod (rootN_ (DetCN (DetQuant DefArt NumSg) (UseN loss_N))) (nmod_ of_Prep (DetCN anySg_Det (ConjCN or_Conj (BaseCN (UseN (CompoundN storage_N medium_N)) (UseN device_N)))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is the loss of any storage medium or device

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_nmod (rootN_ (DetCN (DetQuant DefArt NumSg) (UseN loss_N))) (nmod_ of_Prep (DetCN anySg_Det (ConjCN or_Conj (BaseCN (UseN (CompoundN storage_N medium_N)) (UseN device_N)))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is the loss of any storage medium or device

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = data breach
1	data	data	NOUN	PL-NOM	Number=Sing	2	compound	_	_
2	breach	breach	NOUN	SG-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2] breach 2 (1) NOUN root (root_only (rootN_ (MassNP_sg (UseN (CompoundN data_N breach_N)))) : UDS[1,2]) 1
    [1] data 1 (2) NOUN compound (data_N : N[1]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN (CompoundN data_N breach_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is data breach

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN (CompoundN data_N breach_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is data breach

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = notifiable data breach
1	notifiable	notifiable	ADJ	POS	Degree=Pos	2	amod	_	_
2	data	data	NOUN	PL-NOM	Number=Sing	3	compound	_	_
3	breach	breach	NOUN	SG-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2,3] breach 3 (2) NOUN root (root_only (rootN_ (MassNP_sg (UseN (CompoundCN_ (FakeCN_ (PositA notifiable_A) (UseN data_N)) breach_N)))) : UDS[1,2,3]) 1
    [1,2] data 2 (1) NOUN compound (FakeCN_ (PositA notifiable_A) (UseN data_N) : FakeCN[1,2]) 1
        [1] notifiable 1 (2) ADJ amod (PositA notifiable_A : AP[1]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN (CompoundCN (AdjCN (PositA notifiable_A) (UseN data_N)) breach_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is notifiable data breach

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN (CompoundCN (AdjCN (PositA notifiable_A) (UseN data_N)) breach_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is notifiable data breach

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = the data breach
1	the	the	DET	DEF	Definite=Def|PronType=Art	3	det	_	_
2	data	data	NOUN	PL-NOM	Number=Sing	3	compound	_	_
3	breach	breach	NOUN	SG-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2,3] breach 3 (2) NOUN root (root_only (rootN_ (DetCN (DetQuant DefArt NumSg) (UseN (CompoundN data_N breach_N)))) : UDS[1,2,3]) 1
    [1] the 1 (2) DET det (DetQuant DefArt NumSg : Det[1]) 1
    [2] data 2 (1) NOUN compound (data_N : N[2]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (DetCN (DetQuant DefArt NumSg) (UseN (CompoundN data_N breach_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is the data breach

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (DetCN (DetQuant DefArt NumSg) (UseN (CompoundN data_N breach_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is the data breach

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = results in , [ or ] is likely to result in , significant harm to an affected individual
1	results	result	NOUN	PL-NOM	Number=Plur	14	compound	_	_
2	in	in	ADP	_	_	3	case	_	_
3	,	,	PUNCT	Comma	_	8	punct	_	_
4	[	[	PUNCT	Period	_	8	punct	_	_
5	or	or	CCONJ	_	_	8	cc	_	_
6	]	]	PUNCT	Period	_	5	punct	_	_
7	is	be	AUX	PRES	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	8	cop	_	_
8	likely	like	ADJ	POS	Degree=Pos	1	amod	_	_
9	to	to	PART	_	_	10	mark	_	_
10	result	result	VERB	INF	VerbForm=Inf	8	acl	_	_
11	in	in	ADV	_	_	10	advmod	_	_
12	,	,	PUNCT	Comma	_	8	punct	_	_
13	significant	significant	ADJ	POS	Degree=Pos	14	amod	_	_
14	harm	harm	NOUN	SG-NOM	Number=Sing	0	root	_	_
15	to	to	ADP	_	_	18	case	_	_
16	an	an	DET	IND-SG	Definite=Ind|PronType=Art	18	det	_	_
17	affected	affect	ADJ	PASS	Degree=Pos	18	amod	_	_
18	individual	individual	NOUN	SG-NOM	Number=Sing	14	nmod	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,8,13,14,15,16,17,18] harm 14 (13) NOUN root (root_amod_nmod (rootN_ (MassNP_sg (UseN (CompoundCN_ (FakeCN_ (PositA like_A) (UseN result_N)) harm_N)))) (amod_ (PositA significant_A)) (nmod_ to_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA_ affected_A) (UseN individual_N)))) : UDS[1,8,13,14,15,16,17,18]) 1
    [1,8] results 1 (2) NOUN compound (FakeCN_ (PositA like_A) (UseN result_N) : FakeCN[1,8]) 1
        [8,10,11] likely 8 (7) ADJ amod (PositA like_A : AP[8]) 1
            *[3] , 3 (2) PUNCT punct (comma_Conj : Conj[3]) 1
                *[2] in 2 (1) ADP case (PrepListHead_ in_Prep : PrefixPrep[2]) 1
            *[4] [ 4 (3) PUNCT punct (StrComma "[" : Comma[4]) 1
            *[5] or 5 (4) CCONJ cc (or_Conj : Conj[5]) 1
                *[6] ] 6 (5) PUNCT punct (StrComma "]" : Comma[6]) 1
            *[7] is 7 (6) AUX cop (be_aux : aux[7]) 1
            *[10,11] result 10 (9) VERB acl (root_advmod (rootV_ (UseV result_V)) (advmod_ in_Adv) : UDS[10,11]) 1
                *[9] to 9 (8) PART mark (root_only (rootAdv_ to_Adv) : UDS[9]) 1
                [11] in 11 (10) ADV advmod (advmod_ in_Adv : advmod[11]) 1
            *[12] , 12 (11) PUNCT punct (comma_Conj : Conj[12]) 1
    [13] significant 13 (12) ADJ amod (amod_ (PositA significant_A) : amod[13]) 1
    [15,16,17,18] individual 18 (17) NOUN nmod (nmod_ to_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA_ affected_A) (UseN individual_N))) : nmod[15,16,17,18]) 1
        [15] to 15 (14) ADP case (to_Prep : Prep[15]) 1
        [16] an 16 (15) DET det (DetQuant IndefArt NumSg : Det[16]) 1
        [17] affected 17 (16) ADJ amod (PositA_ affected_A : AP[17]) 1

# at, final GF tree, macros expanded:
root_amod_nmod (rootN_ (MassNP (UseN (CompoundCN (AdjCN (PositA like_A) (UseN result_N)) harm_N)))) (amod_ (PositA significant_A)) (nmod_ to_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA affected_A) (UseN individual_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: 

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_amod_nmod (rootN_ (MassNP (UseN (CompoundCN (AdjCN (PositA like_A) (UseN result_N)) harm_N)))) (amod_ (PositA significant_A)) (nmod_ to_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA affected_A) (UseN individual_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: 

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = is , [ or ] is likely to be , of a significant scale
1	is	be	AUX	PRES	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	7	cop	_	_
2	,	,	PUNCT	Comma	_	7	punct	_	_
3	[	[	PUNCT	Period	_	7	punct	_	_
4	or	or	CCONJ	_	_	7	cc	_	_
5	]	]	PUNCT	Period	_	4	punct	_	_
6	is	be	AUX	PRES	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	7	cop	_	_
7	likely	like	ADJ	POS	Degree=Pos	0	root	_	_
8	to	to	PART	_	_	9	mark	_	_
9	be	be	VERB	INF	VerbForm=Inf	7	acl	_	_
10	,	,	PUNCT	Comma	_	14	punct	_	_
11	of	of	ADP	_	_	14	case	_	_
12	a	a	DET	IND-SG	Definite=Ind|PronType=Art	14	det	_	_
13	significant	significant	ADJ	POS	Degree=Pos	14	amod	_	_
14	scale	scale	NOUN	SG-NOM	Number=Sing	9	obl	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[7,9,11,12,13,14] likely 7 (6) ADJ root (root_acl (rootA_ (PositA like_A)) (aclUDSgerund_ (root_obl (rootV_ (UseV should_V)) (obl_ (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA significant_A) (UseN scale_N))))))) : UDS[7,9,11,12,13,14]) 1
    *[1] is 1 (2) AUX cop (be_aux : aux[1]) 1
    *[2] , 2 (1) PUNCT punct (comma_Conj : Conj[2]) 1
    *[3] [ 3 (2) PUNCT punct (StrComma "[" : Comma[3]) 1
    *[4] or 4 (3) CCONJ cc (or_Conj : Conj[4]) 1
        *[5] ] 5 (4) PUNCT punct (StrComma "]" : Comma[5]) 1
    *[6] is 6 (5) AUX cop (be_aux : aux[6]) 1
    [9,11,12,13,14] be 9 (8) VERB acl (aclUDSgerund_ (root_obl (rootV_ (UseV should_V)) (obl_ (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA significant_A) (UseN scale_N)))))) : acl[9,11,12,13,14]) 1
        *[8] to 8 (7) PART mark (root_only (rootAdv_ to_Adv) : UDS[8]) 1
        [11,12,13,14] scale 14 (13) NOUN obl (obl_ (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA significant_A) (UseN scale_N)))) : obl[11,12,13,14]) 1
            *[10] , 10 (9) PUNCT punct (comma_Conj : Conj[10]) 1
            [11] of 11 (10) ADP case (of_Prep : Prep[11]) 1
            [12] a 12 (11) DET det (DetQuant IndefArt NumSg : Det[12]) 1
            [13] significant 13 (12) ADJ amod (PositA significant_A : AP[13]) 1

# at, final GF tree, macros expanded:
root_acl (rootA_ (PositA like_A)) (aclUDSgerund_ (root_obl (rootV_ (UseV should_V)) (obl_ (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA significant_A) (UseN scale_N)))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is like that should of a significant scale

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_acl (rootA_ (PositA like_A)) (aclUDSgerund_ (root_obl (rootV_ (UseV should_V)) (obl_ (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA significant_A) (UseN scale_N)))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is like that should of a significant scale

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = data breach
1	data	data	NOUN	PL-NOM	Number=Sing	2	compound	_	_
2	breach	breach	NOUN	SG-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2] breach 2 (1) NOUN root (root_only (rootN_ (MassNP_sg (UseN (CompoundN data_N breach_N)))) : UDS[1,2]) 1
    [1] data 1 (2) NOUN compound (data_N : N[1]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN (CompoundN data_N breach_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is data breach

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN (CompoundN data_N breach_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is data breach

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = result in significant harm to an individual
1	result	result	NOUN	SG-NOM	Number=Sing	0	root	_	_
2	in	in	ADP	_	_	4	case	_	_
3	significant	significant	ADJ	POS	Degree=Pos	4	amod	_	_
4	harm	harm	NOUN	SG-NOM	Number=Sing	1	nmod	_	_
5	to	to	ADP	_	_	7	case	_	_
6	an	an	DET	IND-SG	Definite=Ind|PronType=Art	7	det	_	_
7	individual	individual	NOUN	SG-NOM	Number=Sing	4	nmod	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2,3,4,5,6,7] result 1 (2) NOUN root (root_nmod (rootN_ (MassNP_sg (UseN result_N))) (nmod_ in_Prep (MassNP_sg (AdjCN (PositA significant_A) (AdvCN (UseN harm_N) (PrepNP to_Prep (DetCN (DetQuant IndefArt NumSg) (UseN individual_N))))))) : UDS[1,2,3,4,5,6,7]) 1
    [2,3,4,5,6,7] harm 4 (3) NOUN nmod (nmod_ in_Prep (MassNP_sg (AdjCN (PositA significant_A) (AdvCN (UseN harm_N) (PrepNP to_Prep (DetCN (DetQuant IndefArt NumSg) (UseN individual_N)))))) : nmod[2,3,4,5,6,7]) 1
        [2] in 2 (1) ADP case (in_Prep : Prep[2]) 1
        [3] significant 3 (2) ADJ amod (PositA significant_A : AP[3]) 1
        [5,6,7] individual 7 (6) NOUN nmod (PrepNP to_Prep (DetCN (DetQuant IndefArt NumSg) (UseN individual_N)) : Adv[5,6,7]) 1
            [5] to 5 (4) ADP case (to_Prep : Prep[5]) 1
            [6] an 6 (5) DET det (DetQuant IndefArt NumSg : Det[6]) 1

# at, final GF tree, macros expanded:
root_nmod (rootN_ (MassNP (UseN result_N))) (nmod_ in_Prep (MassNP (AdjCN (PositA significant_A) (AdvCN (UseN harm_N) (PrepNP to_Prep (DetCN (DetQuant IndefArt NumSg) (UseN individual_N)))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is result in significant harm to an individual

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_nmod (rootN_ (MassNP (UseN result_N))) (nmod_ in_Prep (MassNP (AdjCN (PositA significant_A) (AdvCN (UseN harm_N) (PrepNP to_Prep (DetCN (DetQuant IndefArt NumSg) (UseN individual_N)))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is result in significant harm to an individual

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = data breach
1	data	data	NOUN	PL-NOM	Number=Sing	2	compound	_	_
2	breach	breach	NOUN	SG-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2] breach 2 (1) NOUN root (root_only (rootN_ (MassNP_sg (UseN (CompoundN data_N breach_N)))) : UDS[1,2]) 1
    [1] data 1 (2) NOUN compound (data_N : N[1]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN (CompoundN data_N breach_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is data breach

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN (CompoundN data_N breach_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is data breach

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = be of a significant scale
1	be	be	AUX	INF	VerbForm=Inf	5	cop	_	_
2	of	of	ADP	_	_	5	case	_	_
3	a	a	DET	IND-SG	Definite=Ind|PronType=Art	5	det	_	_
4	significant	significant	ADJ	POS	Degree=Pos	5	amod	_	_
5	scale	scale	NOUN	SG-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2,3,4,5] scale 5 (4) NOUN root (root_cop (rootAdv_ (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA significant_A) (UseN scale_N))))) be_cop : UDS[1,2,3,4,5]) 1
    [1] be 1 (2) AUX cop (be_cop : cop[1]) 1
    [2] of 2 (1) ADP case (of_Prep : Prep[2]) 1
    [3] a 3 (2) DET det (DetQuant IndefArt NumSg : Det[3]) 1
    [4] significant 4 (3) ADJ amod (PositA significant_A : AP[4]) 1

# at, final GF tree, macros expanded:
root_cop (rootAdv_ (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA significant_A) (UseN scale_N))))) be_cop

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: 

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_cop (rootAdv_ (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA significant_A) (UseN scale_N))))) be_cop

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: 

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = data breach that relates to the unauthorised access , collection , use , disclosure , copying or modification of personal data only within an organisation
1	data	data	NOUN	PL-NOM	Number=Sing	2	compound	_	_
2	breach	breach	NOUN	SG-NOM	Number=Sing	0	root	_	_
3	that	that	PRON	REL	PronType=Rel	4	nsubj	_	_
4	relates	relate	VERB	PRES	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	2	acl:relcl	_	_
5	to	to	ADP	_	_	8	case	_	_
6	the	the	DET	DEF	Definite=Def|PronType=Art	8	det	_	_
7	unauthorised	unauthorised	ADJ	POS	Degree=Pos	8	amod	_	_
8	access	access	NOUN	SG-NOM	Number=Sing	4	obl	_	_
9	,	,	PUNCT	Comma	_	10	punct	_	_
10	collection	collection	NOUN	SG-NOM	Number=Sing	8	conj	_	_
11	,	,	PUNCT	Comma	_	10	punct	_	_
12	use	use	NOUN	SG-NOM	Number=Sing	8	conj	_	_
13	,	,	PUNCT	Comma	_	12	punct	_	_
14	disclosure	disclosure	NOUN	SG-NOM	Number=Sing	8	conj	_	_
15	,	,	PUNCT	Comma	_	16	punct	_	_
16	copying	copy	VERB	ING	Case=Nom	2	advcl	_	_
17	or	or	CCONJ	_	_	18	cc	_	_
18	modification	modification	NOUN	SG-NOM	Number=Sing	16	conj	_	_
19	of	of	ADP	_	_	21	case	_	_
20	personal	personal	ADJ	POS	Degree=Pos	21	amod	_	_
21	data	data	NOUN	PL-NOM	Number=Sing	18	nmod	_	_
22	only	only	ADV	_	_	25	advmod	_	_
23	within	within	ADP	_	_	25	case	_	_
24	an	an	DET	IND-SG	Definite=Ind|PronType=Art	25	det	_	_
25	organisation	organisation	NOUN	SG-NOM	Number=Sing	21	nmod	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2,3,4,5,6,7,8] breach 2 (1) NOUN root (root_aclRelcl (rootN_ (MassNP_sg (UseN (CompoundN data_N breach_N)))) (aclRelclUDS_ (root_nsubj_obl (rootV_ (UseV relate_V)) (nsubj_ (DetNP (DetQuant that_Quant NumSg))) (obl_ (PrepNP to_Prep (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA unauthorized_A) (UseN access_N))))))) : UDS[1,2,3,4,5,6,7,8]) 1
    [1] data 1 (2) NOUN compound (data_N : N[1]) 1
    [3,4,5,6,7,8] relates 4 (3) VERB acl:relcl (aclRelclUDS_ (root_nsubj_obl (rootV_ (UseV relate_V)) (nsubj_ (DetNP (DetQuant that_Quant NumSg))) (obl_ (PrepNP to_Prep (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA unauthorized_A) (UseN access_N)))))) : aclRelcl[3,4,5,6,7,8]) 1
        [3] that 3 (2) PRON nsubj (nsubj_ (DetNP (DetQuant that_Quant NumSg)) : nsubj[3]) 1
        [5,6,7,8] access 8 (7) NOUN obl (obl_ (PrepNP to_Prep (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA unauthorized_A) (UseN access_N)))) : obl[5,6,7,8]) 1
            [5] to 5 (4) ADP case (to_Prep : Prep[5]) 1
            [6] the 6 (5) DET det (DetQuant DefArt NumSg : Det[6]) 1
            [7] unauthorised 7 (6) ADJ amod (PositA unauthorized_A : AP[7]) 1
            *[10] collection 10 (9) NOUN conj (root_only (rootN_ (MassNP_sg (UseN collection_N))) : UDS[10]) 1
                *[9] , 9 (8) PUNCT punct (comma_Conj : Conj[9]) 1
                *[11] , 11 (10) PUNCT punct (comma_Conj : Conj[11]) 1
            *[12] use 12 (11) NOUN conj (root_only (rootN_ (MassNP_sg (UseN use_N))) : UDS[12]) 1
                *[13] , 13 (12) PUNCT punct (comma_Conj : Conj[13]) 1
            *[14] disclosure 14 (13) NOUN conj (root_only (rootN_ (MassNP_sg (UseN disclosure_N))) : UDS[14]) 1
    *[16] copying 16 (15) VERB advcl (root_only (rootV_ (UseV copy_V)) : UDS[16]) 1
        *[15] , 15 (14) PUNCT punct (comma_Conj : Conj[15]) 1
        *[17,18,19,20,21,23,24,25] modification 18 (17) NOUN conj (root_cc_nmod (rootN_ (MassNP_sg (UseN modification_N))) (cc_ or_Conj) (nmod_ of_Prep (MassNP_sg (AdjCN (PositA personal_A) (AdvCN (UseN data_N) (PrepNP within_Prep (DetCN (DetQuant IndefArt NumSg) (UseN organization_N))))))) : UDS[17,18,19,20,21,23,24,25]) 1
            [17] or 17 (16) CCONJ cc (cc_ or_Conj : cc[17]) 1
            [19,20,21,23,24,25] data 21 (20) NOUN nmod (nmod_ of_Prep (MassNP_sg (AdjCN (PositA personal_A) (AdvCN (UseN data_N) (PrepNP within_Prep (DetCN (DetQuant IndefArt NumSg) (UseN organization_N)))))) : nmod[19,20,21,23,24,25]) 1
                [19] of 19 (18) ADP case (of_Prep : Prep[19]) 1
                [20] personal 20 (19) ADJ amod (PositA personal_A : AP[20]) 1
                [22,23,24,25] organisation 25 (24) NOUN nmod (PrepNP within_Prep (DetCN (DetQuant IndefArt NumSg) (UseN organization_N)) : Adv[23,24,25]) 1
                    *[22] only 22 (21) ADV advmod (root_only (rootAdv_ only_Adv) : UDS[22]) 1
                    [23] within 23 (22) ADP case (within_Prep : Prep[23]) 1
                    [24] an 24 (23) DET det (DetQuant IndefArt NumSg : Det[24]) 1

# at, final GF tree, macros expanded:
root_aclRelcl (rootN_ (MassNP (UseN (CompoundN data_N breach_N)))) (aclRelclUDS_ (root_nsubj_obl (rootV_ (UseV relate_V)) (nsubj_ (DetNP (DetQuant that_Quant NumSg))) (obl_ (PrepNP to_Prep (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA unauthorized_A) (UseN access_N)))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is data breach , that relates to the unauthorized access

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_aclRelcl (rootN_ (MassNP (UseN (CompoundN data_N breach_N)))) (aclRelclUDS_ (root_nsubj_obl (rootV_ (UseV relate_V)) (nsubj_ (DetNP (DetQuant that_Quant NumSg))) (obl_ (PrepNP to_Prep (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA unauthorized_A) (UseN access_N)))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is data breach , that relates to the unauthorized access

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = notifiable data breach
1	notifiable	notifiable	ADJ	POS	Degree=Pos	2	amod	_	_
2	data	data	NOUN	PL-NOM	Number=Sing	3	compound	_	_
3	breach	breach	NOUN	SG-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2,3] breach 3 (2) NOUN root (root_only (rootN_ (MassNP_sg (UseN (CompoundCN_ (FakeCN_ (PositA notifiable_A) (UseN data_N)) breach_N)))) : UDS[1,2,3]) 1
    [1,2] data 2 (1) NOUN compound (FakeCN_ (PositA notifiable_A) (UseN data_N) : FakeCN[1,2]) 1
        [1] notifiable 1 (2) ADJ amod (PositA notifiable_A : AP[1]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN (CompoundCN (AdjCN (PositA notifiable_A) (UseN data_N)) breach_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is notifiable data breach

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN (CompoundCN (AdjCN (PositA notifiable_A) (UseN data_N)) breach_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is notifiable data breach

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = data breach that occurs on or after 1 February 2021
1	data	data	NOUN	PL-NOM	Number=Sing	2	compound	_	_
2	breach	breach	NOUN	SG-NOM	Number=Sing	10	compound	_	_
3	that	that	PRON	REL	PronType=Rel	4	nsubj	_	_
4	occurs	occur	VERB	PRES	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	2	acl:relcl	_	_
5	on	on	ADP	_	_	9	case	_	_
6	or	or	CCONJ	_	_	9	cc	_	_
7	after	after	ADP	_	_	9	case	_	_
8	1	1	ADJ	ORD	Case=Nom	9	amod	_	_
9	February	February	PROPN	SG-NOM	Number=Sing	4	obl	_	_
10	2021	2021	NUM	CARD-PL	NumType=Card	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[10] 2021 10 (9) NUM root (root_only (CardNP_ (StrCard "2021")) : UDS[10]) 1
    *[1,2,3,4,7,9] breach 2 (1) NOUN compound (root_aclRelcl (rootN_ (MassNP_sg (UseN (CompoundN data_N breach_N)))) (aclRelclUDS_ (root_nsubj_obl (rootV_ (UseV occur_V)) (nsubj_ (DetNP (DetQuant that_Quant NumSg))) (obl_ (PrepNP on_Prep (UsePN (StrPN "February")))))) : UDS[1,2,3,4,5,9]) 1
        [1] data 1 (2) NOUN compound (data_N : N[1]) 1
        [3,4,7,9] occurs 4 (3) VERB acl:relcl (aclRelclUDS_ (root_nsubj_obl (rootV_ (UseV occur_V)) (nsubj_ (DetNP (DetQuant that_Quant NumSg))) (obl_ (PrepNP on_Prep (UsePN (StrPN "February"))))) : aclRelcl[3,4,5,9]) 1
            [3] that 3 (2) PRON nsubj (nsubj_ (DetNP (DetQuant that_Quant NumSg)) : nsubj[3]) 1
            [6,7,9] February 9 (8) PROPN obl (obl_ (PrepNP on_Prep (UsePN (StrPN "February"))) : obl[5,9]) 1
                [5] on 5 (4) ADP case (on_Prep : Prep[5]) 1
                *[6] or 6 (5) CCONJ cc (or_Conj : Conj[6]) 1
                *[7] after 7 (6) ADP case (PrepListHead_ after_Prep : PrefixPrep[7]) 1
                *[8] 1 8 (7) ADJ amod (root_only (CardNP_ (NumDigits (IDig D_1))) : UDS[8]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (DetNP (DetQuant IndefArt (NumCard (StrCard "2021")))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is 2021

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (DetNP (DetQuant IndefArt (NumCard (StrCard "2021")))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is 2021

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = data intermediary (other than a data intermediary mentioned in section 26E)
1	data	data	NOUN	PL-NOM	Number=Sing	0	root	_	_
2	intermediary	intermediary	ADJ	POS	Degree=Pos	1	amod	_	_
3	(	(	PUNCT	LeftParenthesis	_	4	punct	_	SpaceAfter=No
4	other	other	ADJ	POS	Degree=Pos	1	amod	_	_
5	than	than	ADP	_	_	8	case	_	_
6	a	a	DET	IND-SG	Definite=Ind|PronType=Art	8	det	_	_
7	data	data	NOUN	PL-NOM	Number=Sing	8	compound	_	_
8	intermediary	intermediary	NOUN	SG-NOM	Number=Sing	4	nmod	_	_
9	mentioned	mention	VERB	PASS	Tense=Past|VerbForm=Part|Voice=Pass	8	acl	_	_
10	in	in	ADP	_	_	11	case	_	_
11	section	section	NOUN	SG-NOM	Number=Sing	9	obl	_	_
12	26E	26E	PROPN	SG-NOM	Number=Sing	11	nmod	_	SpaceAfter=No
13	)	)	PUNCT	RightParenthesis	_	1	punct	_	_

# bt0, the best (most complete) tree, without backups:
[1,4,13] data 1 (2) NOUN root (root_only (rootN_ (MassNP_sg (AdjCN (PositA other_A) (UseN data_N)))) : UDS[1,4]) 1
    *[2] intermediary 2 (1) ADJ amod (UseN intermediary_N : CN[2]) 1
    [4,5,6,7,8,9,10,11,12] other 4 (3) ADJ amod (PositA other_A : AP[4]) 1
        *[3] ( 3 (2) PUNCT punct (StrComma "(" : Comma[3]) 1
        *[5,6,7,8,9,10,11,12] intermediary 8 (7) NOUN nmod (root_acl (rootAdv_ (PrepNP than_Prep (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN data_N intermediary_N))))) (aclPastPart_ (root_obl (rootV_ (PassV_ mention_V)) (obl_ (PrepNP in_Prep (MassNP_sg (PossNP (UseN section_N) (UsePN (StrPN "26E")))))))) : UDS[5,6,7,8,9,10,11,12]) 1
            [5] than 5 (4) ADP case (than_Prep : Prep[5]) 1
            [6] a 6 (5) DET det (DetQuant IndefArt NumSg : Det[6]) 1
            [7] data 7 (6) NOUN compound (data_N : N[7]) 1
            [9,10,11,12] mentioned 9 (8) VERB acl (aclPastPart_ (root_obl (rootV_ (PassV_ mention_V)) (obl_ (PrepNP in_Prep (MassNP_sg (PossNP (UseN section_N) (UsePN (StrPN "26E"))))))) : acl[9,10,11,12]) 1
                [10,11,12] section 11 (10) NOUN obl (obl_ (PrepNP in_Prep (MassNP_sg (PossNP (UseN section_N) (UsePN (StrPN "26E"))))) : obl[10,11,12]) 1
                    [10] in 10 (9) ADP case (in_Prep : Prep[10]) 1
                    [12] 26E 12 (11) PROPN nmod (UsePN (StrPN "26E") : NP[12]) 1
    *[13] ) 13 (12) PUNCT punct (StrComma ")" : Comma[13]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (AdjCN (PositA other_A) (UseN data_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is other data

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (AdjCN (PositA other_A) (UseN data_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is other data

# ud, UD tree in CoNLLU format:
# sent_id = 2
# text = *VP has reason to believe that a data breach has occurred in relation to personal data that the data intermediary is processing on behalf of and for the purposes of [ another ] organisation
1	*	*	PUNCT	Period	_	6	punct	_	SpaceAfter=No
2	VP	VP	PROPN	SG-NOM	Number=Sing	6	nsubj	_	_
3	has	have	AUX	PRES-AUX	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	6	aux	_	_
4	reason	reason	NOUN	SG-NOM	Number=Sing	3	obj	_	_
5	to	to	PART	_	_	6	mark	_	_
6	believe	believe	VERB	INF	VerbForm=Inf	0	root	_	_
7	that	that	SCONJ	_	_	12	mark	_	_
8	a	a	DET	IND-SG	Definite=Ind|PronType=Art	10	det	_	_
9	data	data	NOUN	PL-NOM	Number=Sing	10	compound	_	_
10	breach	breach	NOUN	SG-NOM	Number=Sing	12	nsubj:pass	_	_
11	has	have	AUX	PRES-AUX	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	12	aux:pass	_	_
12	occurred	occur	VERB	PASS	Tense=Past|VerbForm=Part|Voice=Pass	6	ccomp	_	_
13	in	in	ADP	_	_	14	case	_	_
14	relation	relation	NOUN	SG-NOM	Number=Sing	12	obl	_	_
15	to	to	ADP	_	_	17	case	_	_
16	personal	personal	ADJ	POS	Degree=Pos	17	amod	_	_
17	data	data	NOUN	PL-NOM	Number=Sing	14	nmod	_	_
18	that	that	SCONJ	_	_	23	mark	_	_
19	the	the	DET	DEF	Definite=Def|PronType=Art	21	det	_	_
20	data	data	NOUN	PL-NOM	Number=Sing	21	compound	_	_
21	intermediary	intermediary	NOUN	SG-NOM	Number=Sing	23	nsubj	_	_
22	is	be	AUX	PRES-AUX	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	23	aux	_	_
23	processing	process	VERB	ING	Tense=Pres|VerbForm=Part	17	acl	_	_
24	on	on	ADP	_	_	25	case	_	_
25	behalf	behalf	NOUN	SG-NOM	Number=Sing	23	obl	_	_
26	of	of	ADP	_	_	27	case	_	_
27	and	and	CCONJ	_	_	30	cc	_	_
28	for	for	ADP	_	_	30	case	_	_
29	the	the	DET	DEF	Definite=Def|PronType=Art	30	det	_	_
30	purposes	purpose	NOUN	PL-NOM	Number=Plur	25	conj	_	_
31	of	of	ADP	_	_	33	case	_	_
32	[	[	PUNCT	Period	_	33	punct	_	_
33	another	another	ADJ	ADJ-SG	_	30	amod	_	_
34	]	]	PUNCT	Period	_	33	punct	_	_
35	organisation	organisation	NOUN	SG-NOM	Number=Sing	6	obj	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[2,6,7,12,13,14,15,16,17,35] believe 6 (5) VERB root (root_nsubj_ccomp (rootV_ (ComplV believe_V (MassNP_sg (UseN organization_N)))) (nsubj_ (UsePN (StrPN "VP"))) (ccomp_ (root_mark (rootV_ (OblVP_ (PassV_ occur_V) (PrepNP in_Prep (MassNP_sg (AdvCN (UseN relation_N) (PrepNP to_Prep (MassNP_sg (AdjCN (PositA personal_A) (UseN data_N))))))))) (mark_ that_Subj))) : UDS[2,6,7,12,13,14,15,16,17,35]) 1
    *[1] * 1 (2) PUNCT punct (StrComma "*" : Comma[1]) 1
    [2] VP 2 (1) PROPN nsubj (nsubj_ (UsePN (StrPN "VP")) : nsubj[2]) 1
    *[3] has 3 (2) AUX aux (have_aux : aux[3]) 1
        *[4] reason 4 (3) NOUN obj (root_only (rootN_ (MassNP_sg (UseN reason_N))) : UDS[4]) 1
    *[5] to 5 (4) PART mark (root_only (rootAdv_ to_Adv) : UDS[5]) 1
    [7,12,13,14,15,16,17] occurred 12 (11) VERB ccomp (ccomp_ (root_mark (rootV_ (OblVP_ (PassV_ occur_V) (PrepNP in_Prep (MassNP_sg (AdvCN (UseN relation_N) (PrepNP to_Prep (MassNP_sg (AdjCN (PositA personal_A) (UseN data_N))))))))) (mark_ that_Subj)) : ccomp[7,12,13,14,15,16,17]) 1
        [7] that 7 (6) SCONJ mark (mark_ that_Subj : mark[7]) 1
        *[8,9,10] breach 10 (9) NOUN nsubj:pass (root_only (rootN_ (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN data_N breach_N)))) : UDS[8,9,10]) 1
            [8] a 8 (7) DET det (DetQuant IndefArt NumSg : Det[8]) 1
            [9] data 9 (8) NOUN compound (data_N : N[9]) 1
        *[11] has 11 (10) AUX aux:pass (have_aux : aux[11]) 1
        [13,14,15,16,17] relation 14 (13) NOUN obl (PrepNP in_Prep (MassNP_sg (AdvCN (UseN relation_N) (PrepNP to_Prep (MassNP_sg (AdjCN (PositA personal_A) (UseN data_N)))))) : Adv[13,14,15,16,17]) 1
            [13] in 13 (12) ADP case (in_Prep : Prep[13]) 1
            [15,16,17,19,20,21,22,23,24,25,27,28,29,30] data 17 (16) NOUN nmod (PrepNP to_Prep (MassNP_sg (AdjCN (PositA personal_A) (UseN data_N))) : Adv[15,16,17]) 1
                [15] to 15 (14) ADP case (to_Prep : Prep[15]) 1
                [16] personal 16 (15) ADJ amod (PositA personal_A : AP[16]) 1
                *[19,20,21,22,23,24,25,27,28,29,30] processing 23 (22) VERB acl (root_mark_nsubj_obl (rootV_ (UseV process_V)) (mark_ that_Subj) (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN (CompoundN data_N intermediary_N)))) (obl_ (Adv2_ (PrepNP on_Prep (MassNP_sg (UseN behalf_N))) (AndAdvPair_ and_Conj (PrepNP for_Prep (DetCN (DetQuant DefArt NumSg) (UseN purpose_N)))))) : UDS[18,19,20,21,23,24,25,27,28,29,30]) 1
                    [18] that 18 (17) SCONJ mark (mark_ that_Subj : mark[18]) 1
                    [19,20,21] intermediary 21 (20) NOUN nsubj (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN (CompoundN data_N intermediary_N))) : nsubj[19,20,21]) 1
                        [19] the 19 (18) DET det (DetQuant DefArt NumSg : Det[19]) 1
                        [20] data 20 (19) NOUN compound (data_N : N[20]) 1
                    *[22] is 22 (21) AUX aux (be_aux : aux[22]) 1
                    [24,25,27,28,29,30] behalf 25 (24) NOUN obl (obl_ (Adv2_ (PrepNP on_Prep (MassNP_sg (UseN behalf_N))) (AndAdvPair_ and_Conj (PrepNP for_Prep (DetCN (DetQuant DefArt NumSg) (UseN purpose_N))))) : obl[24,25,27,28,29,30]) 1
                        [24] on 24 (23) ADP case (on_Prep : Prep[24]) 1
                        [27,28,29,30] purposes 30 (29) NOUN conj (AndAdvPair_ and_Conj (PrepNP for_Prep (DetCN (DetQuant DefArt NumSg) (UseN purpose_N))) : Pair_Conj_Adv[27,28,29,30]) 1
                            [27] and 27 (26) CCONJ cc (and_Conj : Conj[27]) 1
                                *[26] of 26 (25) ADP case (PrepListHead_ of_Prep : PrefixPrep[26]) 1
                            [28] for 28 (27) ADP case (for_Prep : Prep[28]) 1
                            [29] the 29 (28) DET det (DetQuant DefArt NumSg : Det[29]) 1
                            *[33] another 33 (32) ADJ amod (root_only (rootQuant_ another_Quant) : UDS[33]) 1
                                *[31] of 31 (30) ADP case (PrepListHead_ of_Prep : PrefixPrep[31]) 1
                                *[32] [ 32 (31) PUNCT punct (StrComma "[" : Comma[32]) 1
                                *[34] ] 34 (33) PUNCT punct (StrComma "]" : Comma[34]) 1
    [35] organisation 35 (34) NOUN obj (MassNP_sg (UseN organization_N) : NP[35]) 1

# at, final GF tree, macros expanded:
root_nsubj_ccomp (rootV_ (ComplV believe_V (MassNP (UseN organization_N)))) (nsubj_ (UsePN (StrPN "VP"))) (ccomp_ (root_mark (rootV_ (AdvVP (PassV occur_V) (PrepNP in_Prep (MassNP (AdvCN (UseN relation_N) (PrepNP to_Prep (MassNP (AdjCN (PositA personal_A) (UseN data_N))))))))) (mark_ that_Subj)))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: 

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_nsubj_ccomp (rootV_ (ComplV believe_V (MassNP (UseN organization_N)))) (nsubj_ (UsePN (StrPN "VP"))) (ccomp_ (root_mark (rootV_ (AdvVP (PassV occur_V) (PrepNP in_Prep (MassNP (AdvCN (UseN relation_N) (PrepNP to_Prep (MassNP (AdjCN (PositA personal_A) (UseN data_N))))))))) (mark_ that_Subj)))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: 

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = organisation *VP assesses , [ in accordance with ] section 26C , that a data breach is a notifiable data breach , the organisation must notify the Commission as soon as is practicable , but in any case no later than 3 calendar days [ after the ] day the organisation makes that assessment
1	organisation	organisation	NOUN	SG-NOM	Number=Sing	27	obl	_	_
2	*	*	PUNCT	Period	_	1	punct	_	SpaceAfter=No
3	VP	Vp	ADJ	PASS	Degree=Pos	4	amod	_	_
4	assesses	assess	NOUN	PL-NOM	Number=Plur	1	conj	_	_
5	,	,	PUNCT	Comma	_	4	punct	_	_
6	[	[	PUNCT	Period	_	1	punct	_	_
7	in	in	ADP	_	_	8	case	_	_
8	accordance	accordance	NOUN	SG-NOM	Number=Sing	1	nmod	_	_
9	with	with	ADP	_	_	12	case	_	_
10	]	]	PUNCT	Period	_	9	punct	_	_
11	section	section	NOUN	SG-NOM	Number=Sing	12	compound	_	_
12	26C	26c	PROPN	SG-NOM	Number=Sing	8	nmod	_	_
13	,	,	PUNCT	Comma	_	1	punct	_	_
14	that	that	SCONJ	_	_	22	mark	_	_
15	a	a	DET	IND-SG	Definite=Ind|PronType=Art	17	det	_	_
16	data	data	NOUN	PL-NOM	Number=Sing	17	compound	_	_
17	breach	breach	NOUN	SG-NOM	Number=Sing	22	nsubj	_	_
18	is	be	AUX	PRES	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	22	cop	_	_
19	a	a	DET	IND-SG	Definite=Ind|PronType=Art	22	det	_	_
20	notifiable	notifiable	ADJ	POS	Degree=Pos	21	amod	_	_
21	data	data	NOUN	PL-NOM	Number=Sing	22	compound	_	_
22	breach	breach	NOUN	SG-NOM	Number=Sing	1	conj	_	_
23	,	,	PUNCT	Comma	_	1	punct	_	_
24	the	the	DET	DEF	Definite=Def|PronType=Art	25	det	_	_
25	organisation	organisation	NOUN	SG-NOM	Number=Sing	27	nsubj	_	_
26	must	must	AUX	PRES-AUX	VerbForm=Fin	27	aux	_	_
27	notify	notify	VERB	INF	VerbForm=Inf	0	root	_	_
28	the	the	DET	DEF	Definite=Def|PronType=Art	29	det	_	_
29	Commission	commission	NOUN	SG-NOM	Number=Sing	27	obj	_	_
30	as	as	ADV	_	_	31	advmod	_	_
31	soon	soon	ADV	_	Degree=Pos	34	advmod	_	_
32	as	as	ADP	_	_	34	case	_	_
33	is	be	AUX	PRES	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	34	cop	_	_
34	practicable	practicable	ADJ	POS	Degree=Pos	27	advmod	_	_
35	,	,	PUNCT	Comma	_	27	punct	_	_
36	but	but	CCONJ	_	_	41	cc	_	_
37	in	in	ADP	_	_	39	case	_	_
38	any	any	DET	IND	_	39	det	_	_
39	case	case	NOUN	SG-NOM	Number=Sing	41	obl	_	_
40	no	no	DET	NEG	_	41	det	_	_
41	later	late	ADV	CMP	_	27	advmod	_	_
42	than	than	ADP	_	_	45	case	_	_
43	3	3	NUM	ID	NumType=Card	44	nummod	_	_
44	calendar	calendar	NOUN	SG-NOM	Number=Sing	45	compound	_	_
45	days	day	NOUN	PL-NOM	Number=Plur	41	nmod	_	_
46	[	[	PUNCT	Period	_	41	punct	_	_
47	after	after	ADP	_	_	50	case	_	_
48	the	the	DET	DEF	Definite=Def|PronType=Art	50	det	_	_
49	]	]	PUNCT	Period	_	48	punct	_	_
50	day	day	NOUN	SG-NOM	Number=Sing	27	obl	_	_
51	the	the	DET	DEF	Definite=Def|PronType=Art	52	det	_	_
52	organisation	organisation	NOUN	SG-NOM	Number=Sing	53	nsubj	_	_
53	makes	make	VERB	PRES	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	27	advcl	_	_
54	that	that	SCONJ	_	_	55	mark	_	_
55	assessment	assessment	NOUN	SG-NOM	Number=Sing	53	obj	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,7,8,9,12,24,25,26,27,28,29,41,47,48,50,51,52,53,55] notify 27 (26) VERB root (root_nsubj_aux_obj_obl_advmod_advcl (rootV_ (PassVAgent notify_V (MassNP_sg (AdvCN (UseN organization_N) (PrepNP in_Prep (MassNP_sg (AdvCN (UseN accordance_N) (PrepNP with_Prep (UsePN (StrPN "26c")))))))))) (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN organization_N))) must_aux (obj_ (DetCN (DetQuant DefArt NumSg) (UseN commission_N))) (obl_ (PrepNP after_Prep (DetCN (DetQuant DefArt NumSg) (UseN day_N)))) (advmod_ (PositAdvAdj practicable_A)) (advclUDS_ (root_nsubj (rootV_ (ComplV make_V (MassNP_sg (UseN assessment_N)))) (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN organization_N))))) : UDS[1,7,8,9,12,24,25,26,27,28,29,34,47,48,50,51,52,53,55]) 1
    [1,7,8,9,12,19,20,21,22] organisation 1 (2) NOUN obl (MassNP_sg (AdvCN (UseN organization_N) (PrepNP in_Prep (MassNP_sg (AdvCN (UseN accordance_N) (PrepNP with_Prep (UsePN (StrPN "26c"))))))) : NP[1,7,8,9,12]) 1
        *[2] * 2 (1) PUNCT punct (StrComma "*" : Comma[2]) 1
        *[4] assesses 4 (3) NOUN conj (root_only (rootV_ (UseV assess_V)) : UDS[4]) 1
            *[3] VP 3 (2) ADJ amod (root_only (rootA_ (StrAP "VP")) : UDS[3]) 1
            *[5] , 5 (4) PUNCT punct (comma_Conj : Conj[5]) 1
        *[6] [ 6 (5) PUNCT punct (StrComma "[" : Comma[6]) 1
        [7,8,9,12] accordance 8 (7) NOUN nmod (PrepNP in_Prep (MassNP_sg (AdvCN (UseN accordance_N) (PrepNP with_Prep (UsePN (StrPN "26c"))))) : Adv[7,8,9,12]) 1
            [7] in 7 (6) ADP case (in_Prep : Prep[7]) 1
            [9,12] 26C 12 (11) PROPN nmod (PrepNP with_Prep (UsePN (StrPN "26c")) : Adv[9,12]) 1
                [9,10] with 9 (8) ADP case (with_Prep : Prep[9]) 1
                    *[10] ] 10 (9) PUNCT punct (StrComma "]" : Comma[10]) 1
                *[11] section 11 (10) NOUN compound (root_only (rootN_ (MassNP_sg (UseN section_N))) : UDS[11]) 1
        *[13] , 13 (12) PUNCT punct (comma_Conj : Conj[13]) 1
        *[14,15,16,17,18,19,20,21,22] breach 22 (21) NOUN conj (root_mark_nsubj_cop (rootN_ (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundCN_ (FakeCN_ (PositA notifiable_A) (UseN data_N)) breach_N)))) (mark_ that_Subj) (nsubj_ (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN data_N breach_N)))) be_cop : UDS[14,15,16,17,18,19,20,21,22]) 1
            [14] that 14 (13) SCONJ mark (mark_ that_Subj : mark[14]) 1
            [15,16,17] breach 17 (16) NOUN nsubj (nsubj_ (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN data_N breach_N))) : nsubj[15,16,17]) 1
                [15] a 15 (14) DET det (DetQuant IndefArt NumSg : Det[15]) 1
                [16] data 16 (15) NOUN compound (data_N : N[16]) 1
            [18] is 18 (17) AUX cop (be_cop : cop[18]) 1
            [19] a 19 (18) DET det (DetQuant IndefArt NumSg : Det[19]) 1
            [20,21] data 21 (20) NOUN compound (FakeCN_ (PositA notifiable_A) (UseN data_N) : FakeCN[20,21]) 1
                [20] notifiable 20 (19) ADJ amod (PositA notifiable_A : AP[20]) 1
        *[23] , 23 (22) PUNCT punct (comma_Conj : Conj[23]) 1
    [24,25] organisation 25 (24) NOUN nsubj (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN organization_N)) : nsubj[24,25]) 1
        [24] the 24 (23) DET det (DetQuant DefArt NumSg : Det[24]) 1
    [26] must 26 (25) AUX aux (must_aux : aux[26]) 1
    [28,29] Commission 29 (28) NOUN obj (obj_ (DetCN (DetQuant DefArt NumSg) (UseN commission_N)) : obj[28,29]) 1
        [28] the 28 (27) DET det (DetQuant DefArt NumSg : Det[28]) 1
    [31,33,34] practicable 34 (33) ADJ advmod (advmod_ (PositAdvAdj practicable_A) : advmod[34]) 1
        *[31] soon 31 (30) ADV advmod (root_only (rootAdv_ soon_Adv) : UDS[31]) 1
            *[30] as 30 (29) ADV advmod (AdnCAdv as_CAdv : AdN[30]) 1
        *[32] as 32 (31) ADP case (PrepListHead_ as_Prep : PrefixPrep[32]) 1
        *[33] is 33 (32) AUX cop (be_aux : aux[33]) 1
    *[35] , 35 (34) PUNCT punct (comma_Conj : Conj[35]) 1
    *[36,40,41,42,44,45] later 41 (40) ADV advmod (root_cc_det_nmod (rootAdv_ late_Adv) (cc_ but_Conj) (det_ (DetQuant no_Quant NumSg)) (nmod_ than_Prep (DetCN_aPl (UseN (CompoundN calendar_N day_N)))) : UDS[36,40,41,42,44,45]) 1
        [36] but 36 (35) CCONJ cc (cc_ but_Conj : cc[36]) 1
        *[37,38,39] case 39 (38) NOUN obl (root_only (rootAdv_ (PrepNP in_Prep (DetCN_anySg anyPl_Det (UseN case_N)))) : UDS[37,38,39]) 1
            [37] in 37 (36) ADP case (in_Prep : Prep[37]) 1
            [38] any 38 (37) DET det (anyPl_Det : Det[38]) 1
        [40] no 40 (39) DET det (det_ (DetQuant no_Quant NumSg) : det[40]) 1
        [42,44,45] days 45 (44) NOUN nmod (nmod_ than_Prep (DetCN_aPl (UseN (CompoundN calendar_N day_N))) : nmod[42,44,45]) 1
            [42] than 42 (41) ADP case (than_Prep : Prep[42]) 1
            [43,44] calendar 44 (43) NOUN compound (calendar_N : N[44]) 1
                *[43] 3 43 (42) NUM nummod (root_only (CardNP_ (NumDigits (IDig D_3))) : UDS[43]) 1
        *[46] [ 46 (45) PUNCT punct (StrComma "[" : Comma[46]) 1
    [47,48,50] day 50 (49) NOUN obl (obl_ (PrepNP after_Prep (DetCN (DetQuant DefArt NumSg) (UseN day_N))) : obl[47,48,50]) 1
        [47] after 47 (46) ADP case (after_Prep : Prep[47]) 1
        [48,49] the 48 (47) DET det (DetQuant DefArt NumSg : Det[48]) 1
            *[49] ] 49 (48) PUNCT punct (StrComma "]" : Comma[49]) 1
    [51,52,53,55] makes 53 (52) VERB advcl (advclUDS_ (root_nsubj (rootV_ (ComplV make_V (MassNP_sg (UseN assessment_N)))) (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN organization_N)))) : advcl[51,52,53,55]) 1
        [51,52] organisation 52 (51) NOUN nsubj (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN organization_N)) : nsubj[51,52]) 1
            [51] the 51 (50) DET det (DetQuant DefArt NumSg : Det[51]) 1
        [54,55] assessment 55 (54) NOUN obj (MassNP_sg (UseN assessment_N) : NP[55]) 1
            *[54] that 54 (53) SCONJ mark (that_Subj : Subj[54]) 1

# at, final GF tree, macros expanded:
root_nsubj_aux_obj_obl_advmod_advcl (rootV_ (PassVAgent notify_V (MassNP (AdvCN (UseN organization_N) (PrepNP in_Prep (MassNP (AdvCN (UseN accordance_N) (PrepNP with_Prep (UsePN (StrPN "26c")))))))))) (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN organization_N))) must_aux (obj_ (DetCN (DetQuant DefArt NumSg) (UseN commission_N))) (obl_ (PrepNP after_Prep (DetCN (DetQuant DefArt NumSg) (UseN day_N)))) (advmod_ (PositAdvAdj practicable_A)) (advclUDS_ (root_nsubj (rootV_ (ComplV make_V (MassNP (UseN assessment_N)))) (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN organization_N)))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: 

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_nsubj_aux_obj_obl_advmod_advcl (rootV_ (PassVAgent notify_V (MassNP (AdvCN (UseN organization_N) (PrepNP in_Prep (MassNP (AdvCN (UseN accordance_N) (PrepNP with_Prep (UsePN (StrPN "26c")))))))))) (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN organization_N))) must_aux (obj_ (DetCN (DetQuant DefArt NumSg) (UseN commission_N))) (obl_ (PrepNP after_Prep (DetCN (DetQuant DefArt NumSg) (UseN day_N)))) (advmod_ (PositAdvAdj practicable_A)) (advclUDS_ (root_nsubj (rootV_ (ComplV make_V (MassNP (UseN assessment_N)))) (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN organization_N)))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: 

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = the organisation
1	the	the	DET	DEF	Definite=Def|PronType=Art	2	det	_	_
2	organisation	organisation	NOUN	SG-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2] organisation 2 (1) NOUN root (root_only (rootN_ (DetCN (DetQuant DefArt NumSg) (UseN organization_N))) : UDS[1,2]) 1
    [1] the 1 (2) DET det (DetQuant DefArt NumSg : Det[1]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (DetCN (DetQuant DefArt NumSg) (UseN organization_N)))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is the organization

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (DetCN (DetQuant DefArt NumSg) (UseN organization_N)))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is the organization

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = takes any action , in accordance with any prescribed requirements , that renders it unlikely that the notifiable data breach will result in significant harm to the affected individual
1	takes	take	VERB	PRES	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	0	root	_	_
2	any	any	DET	IND	_	3	det	_	_
3	action	action	NOUN	SG-NOM	Number=Sing	1	obj	_	_
4	,	,	PUNCT	Comma	_	3	punct	_	_
5	in	in	ADP	_	_	6	case	_	_
6	accordance	accordance	NOUN	SG-NOM	Number=Sing	1	obl	_	_
7	with	with	ADP	_	_	10	case	_	_
8	any	any	DET	IND	_	10	det	_	_
9	prescribed	prescribe	NOUN	SG-NOM	Number=Sing	10	compound	_	_
10	requirements	requirement	NOUN	PL-NOM	Number=Plur	1	obl	_	_
11	,	,	PUNCT	Comma	_	10	punct	_	_
12	that	that	PRON	REL	PronType=Rel	13	nsubj	_	_
13	renders	render	VERB	PRES	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	10	acl:relcl	_	_
14	it	it	PRON	PERS-SG	_	13	obj	_	_
15	unlikely	unlikely	ADJ	POS	Degree=Pos	13	xcomp	_	_
16	that	that	SCONJ	_	_	22	mark	_	_
17	the	the	DET	DEF	Definite=Def|PronType=Art	20	det	_	_
18	notifiable	notifiable	ADJ	POS	Degree=Pos	19	amod	_	_
19	data	data	NOUN	PL-NOM	Number=Sing	20	compound	_	_
20	breach	breach	NOUN	SG-NOM	Number=Sing	22	nsubj	_	_
21	will	will	AUX	PRES-AUX	VerbForm=Fin	22	aux	_	_
22	result	result	VERB	INF	VerbForm=Inf	15	acl	_	_
23	in	in	ADP	_	_	25	case	_	_
24	significant	significant	ADJ	POS	Degree=Pos	25	amod	_	_
25	harm	harm	NOUN	SG-NOM	Number=Sing	22	obl	_	_
26	to	to	ADP	_	_	29	case	_	_
27	the	the	DET	DEF	Definite=Def|PronType=Art	29	det	_	_
28	affected	affect	ADJ	PASS	Degree=Pos	29	amod	_	_
29	individual	individual	NOUN	SG-NOM	Number=Sing	25	nmod	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2,3,5,6,7,8,10] takes 1 (2) VERB root (root_obl_obl (rootV_ (ComplV take_V (DetCN_anySg anyPl_Det (UseN action_N)))) (obl_ (PrepNP in_Prep (MassNP_sg (UseN accordance_N)))) (obl_ (PrepNP with_Prep (DetCN_anyPl anyPl_Det (UseN requirement_N)))) : UDS[1,2,3,5,6,7,8,10]) 1
    [2,3] action 3 (2) NOUN obj (DetCN_anySg anyPl_Det (UseN action_N) : NP[2,3]) 1
        [2] any 2 (1) DET det (anyPl_Det : Det[2]) 1
        *[4] , 4 (3) PUNCT punct (comma_Conj : Conj[4]) 1
    [5,6] accordance 6 (5) NOUN obl (obl_ (PrepNP in_Prep (MassNP_sg (UseN accordance_N))) : obl[5,6]) 1
        [5] in 5 (4) ADP case (in_Prep : Prep[5]) 1
    [7,8,10,12,13,14,15] requirements 10 (9) NOUN obl (obl_ (PrepNP with_Prep (DetCN_anyPl anyPl_Det (UseN requirement_N))) : obl[7,8,10]) 1
        [7] with 7 (6) ADP case (with_Prep : Prep[7]) 1
        [8] any 8 (7) DET det (anyPl_Det : Det[8]) 1
        *[9] prescribed 9 (8) NOUN compound (root_only (rootV_ (UseV prescribe_V)) : UDS[9]) 1
        *[11] , 11 (10) PUNCT punct (comma_Conj : Conj[11]) 1
        *[12,13,14,15] renders 13 (12) VERB acl:relcl (root_nsubj_obj_xcomp (rootV_ (UseV render_V)) (nsubj_ (DetNP (DetQuant that_Quant NumSg))) (obj_ (DetNP (DetQuant DefArt NumSg))) (xcompA_ (PositA unlikely_A)) : UDS[12,13,14,15]) 1
            [12] that 12 (11) PRON nsubj (nsubj_ (DetNP (DetQuant that_Quant NumSg)) : nsubj[12]) 1
            [14] it 14 (13) PRON obj (obj_ (DetNP (DetQuant DefArt NumSg)) : obj[14]) 1
            [15,17,18,19,20,21,22,23,24,25,26,27,28,29] unlikely 15 (14) ADJ xcomp (xcompA_ (PositA unlikely_A) : xcomp[15]) 1
                *[17,18,19,20,21,22,23,24,25,26,27,28,29] result 22 (21) VERB acl (root_mark_nsubj_obl (rootV_ (UseV result_V)) (mark_ that_Subj) (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN (CompoundCN_ (FakeCN_ (PositA notifiable_A) (UseN data_N)) breach_N)))) (obl_ (PrepNP in_Prep (MassNP_sg (AdjCN (PositA significant_A) (AdvCN (UseN harm_N) (PrepNP to_Prep (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA_ affected_A) (UseN individual_N))))))))) : UDS[16,17,18,19,20,22,23,24,25,26,27,28,29]) 1
                    [16] that 16 (15) SCONJ mark (mark_ that_Subj : mark[16]) 1
                    [17,18,19,20] breach 20 (19) NOUN nsubj (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN (CompoundCN_ (FakeCN_ (PositA notifiable_A) (UseN data_N)) breach_N))) : nsubj[17,18,19,20]) 1
                        [17] the 17 (16) DET det (DetQuant DefArt NumSg : Det[17]) 1
                        [18,19] data 19 (18) NOUN compound (FakeCN_ (PositA notifiable_A) (UseN data_N) : FakeCN[18,19]) 1
                            [18] notifiable 18 (17) ADJ amod (PositA notifiable_A : AP[18]) 1
                    *[21] will 21 (20) AUX aux (will_aux : aux[21]) 1
                    [23,24,25,26,27,28,29] harm 25 (24) NOUN obl (obl_ (PrepNP in_Prep (MassNP_sg (AdjCN (PositA significant_A) (AdvCN (UseN harm_N) (PrepNP to_Prep (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA_ affected_A) (UseN individual_N)))))))) : obl[23,24,25,26,27,28,29]) 1
                        [23] in 23 (22) ADP case (in_Prep : Prep[23]) 1
                        [24] significant 24 (23) ADJ amod (PositA significant_A : AP[24]) 1
                        [26,27,28,29] individual 29 (28) NOUN nmod (PrepNP to_Prep (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA_ affected_A) (UseN individual_N))) : Adv[26,27,28,29]) 1
                            [26] to 26 (25) ADP case (to_Prep : Prep[26]) 1
                            [27] the 27 (26) DET det (DetQuant DefArt NumSg : Det[27]) 1
                            [28] affected 28 (27) ADJ amod (PositA_ affected_A : AP[28]) 1

# at, final GF tree, macros expanded:
root_obl_obl (rootV_ (ComplV take_V (DetCN anySg_Det (UseN action_N)))) (obl_ (PrepNP in_Prep (MassNP (UseN accordance_N)))) (obl_ (PrepNP with_Prep (DetCN anyPl_Det (UseN requirement_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: takes any action in accordance with any requirements

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_obl_obl (rootV_ (ComplV take_V (DetCN anySg_Det (UseN action_N)))) (obl_ (PrepNP in_Prep (MassNP (UseN accordance_N)))) (obl_ (PrepNP with_Prep (DetCN anyPl_Det (UseN requirement_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: takes any action in accordance with any requirements

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = had implemented , [ prior to the occurrence of ] the notifiable data breach , any technological measure that renders it unlikely that the notifiable data breach will result in significant harm to the affected individual
1	had	have	AUX	PAST-AUX	Mood=Ind|Tense=Past|VerbForm=Fin	2	aux	_	_
2	implemented	implement	VERB	PERF	Tense=Past|VerbForm=Part	0	root	_	_
3	,	,	PUNCT	Comma	_	2	punct	_	_
4	[	[	PUNCT	Period	_	2	punct	_	_
5	prior	prior	NOUN	SG-NOM	Number=Sing	2	conj	_	_
6	to	to	ADP	_	_	8	case	_	_
7	the	the	DET	DEF	Definite=Def|PronType=Art	8	det	_	_
8	occurrence	occurrence	NOUN	SG-NOM	Number=Sing	5	nmod	_	_
9	of	of	ADP	_	_	14	case	_	_
10	]	]	PUNCT	Period	_	14	punct	_	_
11	the	the	DET	DEF	Definite=Def|PronType=Art	14	det	_	_
12	notifiable	notifiable	ADJ	POS	Degree=Pos	13	amod	_	_
13	data	data	NOUN	PL-NOM	Number=Sing	14	compound	_	_
14	breach	breach	NOUN	SG-NOM	Number=Sing	8	nmod	_	_
15	,	,	PUNCT	Comma	_	5	punct	_	_
16	any	any	DET	IND	_	18	det	_	_
17	technological	technological	ADJ	POS	Degree=Pos	18	amod	_	_
18	measure	measure	NOUN	SG-NOM	Number=Sing	2	conj	_	_
19	that	that	PRON	REL	PronType=Rel	20	nsubj	_	_
20	renders	render	VERB	PRES	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	18	acl:relcl	_	_
21	it	it	PRON	PERS-SG	_	20	obj	_	_
22	unlikely	unlikely	ADJ	POS	Degree=Pos	20	xcomp	_	_
23	that	that	SCONJ	_	_	29	mark	_	_
24	the	the	DET	DEF	Definite=Def|PronType=Art	27	det	_	_
25	notifiable	notifiable	ADJ	POS	Degree=Pos	26	amod	_	_
26	data	data	NOUN	PL-NOM	Number=Sing	27	compound	_	_
27	breach	breach	NOUN	SG-NOM	Number=Sing	29	nsubj	_	_
28	will	will	AUX	PRES-AUX	VerbForm=Fin	29	aux	_	_
29	result	result	VERB	INF	VerbForm=Inf	22	acl	_	_
30	in	in	ADP	_	_	32	case	_	_
31	significant	significant	ADJ	POS	Degree=Pos	32	amod	_	_
32	harm	harm	NOUN	SG-NOM	Number=Sing	29	obl	_	_
33	to	to	ADP	_	_	36	case	_	_
34	the	the	DET	DEF	Definite=Def|PronType=Art	36	det	_	_
35	affected	affect	ADJ	PASS	Degree=Pos	36	amod	_	_
36	individual	individual	NOUN	SG-NOM	Number=Sing	32	nmod	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[2] implemented 2 (1) VERB root (root_only (rootV_ (UseV implement_V)) : UDS[2]) 1
    *[1] had 1 (2) AUX aux (have_aux : aux[1]) 1
    *[3] , 3 (2) PUNCT punct (comma_Conj : Conj[3]) 1
    *[4] [ 4 (3) PUNCT punct (StrComma "[" : Comma[4]) 1
    *[5,6,7,8,9,11,12,13,14] prior 5 (4) NOUN conj (root_nmod (rootN_ (MassNP_sg (UseN prior_N))) (nmod_ to_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN occurrence_N)) (PrepNP of_Prep (DetCN (DetQuant DefArt NumSg) (UseN (CompoundCN_ (FakeCN_ (PositA notifiable_A) (UseN data_N)) breach_N)))))) : UDS[5,6,7,8,9,11,12,13,14]) 1
        [6,7,8,9,11,12,13,14] occurrence 8 (7) NOUN nmod (nmod_ to_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN occurrence_N)) (PrepNP of_Prep (DetCN (DetQuant DefArt NumSg) (UseN (CompoundCN_ (FakeCN_ (PositA notifiable_A) (UseN data_N)) breach_N))))) : nmod[6,7,8,9,11,12,13,14]) 1
            [6] to 6 (5) ADP case (to_Prep : Prep[6]) 1
            [7] the 7 (6) DET det (DetQuant DefArt NumSg : Det[7]) 1
            [9,10,11,12,13,14] breach 14 (13) NOUN nmod (PrepNP of_Prep (DetCN (DetQuant DefArt NumSg) (UseN (CompoundCN_ (FakeCN_ (PositA notifiable_A) (UseN data_N)) breach_N))) : Adv[9,11,12,13,14]) 1
                [9] of 9 (8) ADP case (of_Prep : Prep[9]) 1
                *[10] ] 10 (9) PUNCT punct (StrComma "]" : Comma[10]) 1
                [11] the 11 (10) DET det (DetQuant DefArt NumSg : Det[11]) 1
                [12,13] data 13 (12) NOUN compound (FakeCN_ (PositA notifiable_A) (UseN data_N) : FakeCN[12,13]) 1
                    [12] notifiable 12 (11) ADJ amod (PositA notifiable_A : AP[12]) 1
        *[15] , 15 (14) PUNCT punct (comma_Conj : Conj[15]) 1
    *[16,17,18,19,20,21,22] measure 18 (17) NOUN conj (root_aclRelcl (rootN_ (DetCN_anySg anyPl_Det (AdjCN (PositA technological_A) (UseN measure_N)))) (aclRelclUDS_ (root_nsubj_obj_xcomp (rootV_ (UseV render_V)) (nsubj_ (DetNP (DetQuant that_Quant NumSg))) (obj_ (DetNP (DetQuant DefArt NumSg))) (xcompA_ (PositA unlikely_A)))) : UDS[16,17,18,19,20,21,22]) 1
        [16] any 16 (15) DET det (anyPl_Det : Det[16]) 1
        [17] technological 17 (16) ADJ amod (PositA technological_A : AP[17]) 1
        [19,20,21,22] renders 20 (19) VERB acl:relcl (aclRelclUDS_ (root_nsubj_obj_xcomp (rootV_ (UseV render_V)) (nsubj_ (DetNP (DetQuant that_Quant NumSg))) (obj_ (DetNP (DetQuant DefArt NumSg))) (xcompA_ (PositA unlikely_A))) : aclRelcl[19,20,21,22]) 1
            [19] that 19 (18) PRON nsubj (nsubj_ (DetNP (DetQuant that_Quant NumSg)) : nsubj[19]) 1
            [21] it 21 (20) PRON obj (obj_ (DetNP (DetQuant DefArt NumSg)) : obj[21]) 1
            [22,24,25,26,27,28,29,30,31,32,33,34,35,36] unlikely 22 (21) ADJ xcomp (xcompA_ (PositA unlikely_A) : xcomp[22]) 1
                *[24,25,26,27,28,29,30,31,32,33,34,35,36] result 29 (28) VERB acl (root_mark_nsubj_obl (rootV_ (UseV result_V)) (mark_ that_Subj) (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN (CompoundCN_ (FakeCN_ (PositA notifiable_A) (UseN data_N)) breach_N)))) (obl_ (PrepNP in_Prep (MassNP_sg (AdjCN (PositA significant_A) (AdvCN (UseN harm_N) (PrepNP to_Prep (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA_ affected_A) (UseN individual_N))))))))) : UDS[23,24,25,26,27,29,30,31,32,33,34,35,36]) 1
                    [23] that 23 (22) SCONJ mark (mark_ that_Subj : mark[23]) 1
                    [24,25,26,27] breach 27 (26) NOUN nsubj (nsubj_ (DetCN (DetQuant DefArt NumSg) (UseN (CompoundCN_ (FakeCN_ (PositA notifiable_A) (UseN data_N)) breach_N))) : nsubj[24,25,26,27]) 1
                        [24] the 24 (23) DET det (DetQuant DefArt NumSg : Det[24]) 1
                        [25,26] data 26 (25) NOUN compound (FakeCN_ (PositA notifiable_A) (UseN data_N) : FakeCN[25,26]) 1
                            [25] notifiable 25 (24) ADJ amod (PositA notifiable_A : AP[25]) 1
                    *[28] will 28 (27) AUX aux (will_aux : aux[28]) 1
                    [30,31,32,33,34,35,36] harm 32 (31) NOUN obl (obl_ (PrepNP in_Prep (MassNP_sg (AdjCN (PositA significant_A) (AdvCN (UseN harm_N) (PrepNP to_Prep (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA_ affected_A) (UseN individual_N)))))))) : obl[30,31,32,33,34,35,36]) 1
                        [30] in 30 (29) ADP case (in_Prep : Prep[30]) 1
                        [31] significant 31 (30) ADJ amod (PositA significant_A : AP[31]) 1
                        [33,34,35,36] individual 36 (35) NOUN nmod (PrepNP to_Prep (DetCN (DetQuant DefArt NumSg) (AdjCN (PositA_ affected_A) (UseN individual_N))) : Adv[33,34,35,36]) 1
                            [33] to 33 (32) ADP case (to_Prep : Prep[33]) 1
                            [34] the 34 (33) DET det (DetQuant DefArt NumSg : Det[34]) 1
                            [35] affected 35 (34) ADJ amod (PositA_ affected_A : AP[35]) 1

# at, final GF tree, macros expanded:
root_only (rootV_ (UseV implement_V))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: implements

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootV_ (UseV implement_V))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: implements

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = organisation
1	organisation	organisation	NOUN	SG-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1] organisation 1 (2) NOUN root (root_only (rootN_ (MassNP_sg (UseN organization_N))) : UDS[1]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN organization_N)))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is organization

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN organization_N)))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is organization

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = notify any affected individual
1	notify	notify	ADV	_	_	4	advmod	_	_
2	any	any	DET	IND	_	4	det	_	_
3	affected	affect	ADJ	PASS	Degree=Pos	4	amod	_	_
4	individual	individual	NOUN	SG-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[2,3,4] individual 4 (3) NOUN root (root_only (rootN_ (DetCN_anySg anyPl_Det (AdjCN (PositA_ affected_A) (UseN individual_N)))) : UDS[2,3,4]) 1
    *[1] notify 1 (2) ADV advmod (root_only (rootV_ (UseV notify_V)) : UDS[1]) 1
    [2] any 2 (1) DET det (anyPl_Det : Det[2]) 1
    [3] affected 3 (2) ADJ amod (PositA_ affected_A : AP[3]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (DetCN anySg_Det (AdjCN (PositA affected_A) (UseN individual_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is any affected individual

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (DetCN anySg_Det (AdjCN (PositA affected_A) (UseN individual_N))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is any affected individual

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = organisation
1	organisation	organisation	NOUN	SG-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1] organisation 1 (2) NOUN root (root_only (rootN_ (MassNP_sg (UseN organization_N))) : UDS[1]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN organization_N)))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is organization

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN organization_N)))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is organization

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = being in breach
1	being	be	AUX	ING	Tense=Pres|VerbForm=Part	0	root	_	_
2	in	in	ADP	_	_	3	case	_	_
3	breach	breach	NOUN	SG-NOM	Number=Sing	1	obl	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1] being 1 (2) AUX root (be_aux : aux[1]) 1
    *[2,3] breach 3 (2) NOUN obl (root_only (rootAdv_ (PrepNP in_Prep (MassNP_sg (UseN breach_N)))) : UDS[2,3]) 1
        [2] in 2 (1) ADP case (in_Prep : Prep[2]) 1

# at, final GF tree, macros expanded:
be_aux

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: be

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
be_aux

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: be

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = duty [ or ] obligation under any written law or rule of law , [ or ] any contract , as to secrecy [ or ] other restriction on the disclosure of information
1	duty	duty	NOUN	SG-NOM	Number=Sing	0	root	_	_
2	[	[	PUNCT	Period	_	5	punct	_	_
3	or	or	CCONJ	_	_	5	cc	_	_
4	]	]	PUNCT	Period	_	3	punct	_	_
5	obligation	obligation	NOUN	SG-NOM	Number=Sing	1	conj	_	_
6	under	under	ADP	_	_	9	case	_	_
7	any	any	DET	IND	_	9	det	_	_
8	written	write	ADJ	PASS	Case=Nom	9	amod	_	_
9	law	law	NOUN	SG-NOM	Number=Sing	1	nmod	_	_
10	or	or	CCONJ	_	_	11	cc	_	_
11	rule	rule	NOUN	SG-NOM	Number=Sing	9	conj	_	_
12	of	of	ADP	_	_	13	case	_	_
13	law	law	NOUN	SG-NOM	Number=Sing	11	nmod	_	_
14	,	,	PUNCT	Comma	_	15	punct	_	_
15	[	[	PUNCT	Period	_	19	punct	_	_
16	or	or	CCONJ	_	_	19	cc	_	_
17	]	]	PUNCT	Period	_	19	punct	_	_
18	any	any	DET	IND	_	19	det	_	_
19	contract	contract	NOUN	SG-NOM	Number=Sing	13	conj	_	_
20	,	,	PUNCT	Comma	_	23	punct	_	_
21	as	as	SCONJ	_	_	23	mark	_	_
22	to	to	PART	_	_	23	mark	_	_
23	secrecy	secrecy	VERB	INF	VerbForm=Inf	19	acl	_	_
24	[	[	PUNCT	Period	_	28	punct	_	_
25	or	or	CCONJ	_	_	28	cc	_	_
26	]	]	PUNCT	Period	_	25	punct	_	_
27	other	other	ADJ	POS	Degree=Pos	28	amod	_	_
28	restriction	restriction	NOUN	SG-NOM	Number=Sing	23	conj	_	_
29	on	on	ADP	_	_	31	case	_	_
30	the	the	DET	DEF	Definite=Def|PronType=Art	31	det	_	_
31	disclosure	disclosure	NOUN	SG-NOM	Number=Sing	28	nmod	_	_
32	of	of	ADP	_	_	33	case	_	_
33	information	information	NOUN	SG-NOM	Number=Sing	31	nmod	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,3,5,6,7,8,9,10,11,12,13,16,18,19] duty 1 (2) NOUN root (root_nmod (rootN_ (MassNP_sg (CN2_ (UseN duty_N) (AndCNPair_ or_Conj (UseN obligation_N))))) (nmod_ under_Prep (DetCN_anySg anyPl_Det (CN2_ (AdjCN (PositA written_A) (UseN law_N)) (AndCNPair_ or_Conj (AdvCN (UseN rule_N) (PrepNP of_Prep (NP2_ (MassNP_sg (UseN law_N)) (AndDogPair_ or_Conj (DetCN_anySg anyPl_Det (UseN contract_N)))))))))) : UDS[1,3,5,6,7,8,9,10,11,12,13,16,18,19]) 1
    [3,5] obligation 5 (4) NOUN conj (AndCNPair_ or_Conj (UseN obligation_N) : Pair_Conj_CN[3,5]) 1
        *[2] [ 2 (1) PUNCT punct (StrComma "[" : Comma[2]) 1
        [3] or 3 (2) CCONJ cc (or_Conj : Conj[3]) 1
            *[4] ] 4 (3) PUNCT punct (StrComma "]" : Comma[4]) 1
    [6,7,8,9,10,11,12,13,16,18,19] law 9 (8) NOUN nmod (nmod_ under_Prep (DetCN_anySg anyPl_Det (CN2_ (AdjCN (PositA written_A) (UseN law_N)) (AndCNPair_ or_Conj (AdvCN (UseN rule_N) (PrepNP of_Prep (NP2_ (MassNP_sg (UseN law_N)) (AndDogPair_ or_Conj (DetCN_anySg anyPl_Det (UseN contract_N))))))))) : nmod[6,7,8,9,10,11,12,13,16,18,19]) 1
        [6] under 6 (5) ADP case (under_Prep : Prep[6]) 1
        [7] any 7 (6) DET det (anyPl_Det : Det[7]) 1
        [8] written 8 (7) ADJ amod (PositA written_A : AP[8]) 1
        [10,11,12,13,16,18,19] rule 11 (10) NOUN conj (AndCNPair_ or_Conj (AdvCN (UseN rule_N) (PrepNP of_Prep (NP2_ (MassNP_sg (UseN law_N)) (AndDogPair_ or_Conj (DetCN_anySg anyPl_Det (UseN contract_N)))))) : Pair_Conj_CN[10,11,12,13,16,18,19]) 1
            [10] or 10 (9) CCONJ cc (or_Conj : Conj[10]) 1
            [12,13,16,18,19] law 13 (12) NOUN nmod (PrepNP of_Prep (NP2_ (MassNP_sg (UseN law_N)) (AndDogPair_ or_Conj (DetCN_anySg anyPl_Det (UseN contract_N)))) : Adv[12,13,16,18,19]) 1
                [12] of 12 (11) ADP case (of_Prep : Prep[12]) 1
                [16,18,19] contract 19 (18) NOUN conj (AndDogPair_ or_Conj (DetCN_anySg anyPl_Det (UseN contract_N)) : Pair_Conj_NP[16,18,19]) 1
                    *[15] [ 15 (14) PUNCT punct (StrComma "[" : Comma[15]) 1
                        *[14] , 14 (13) PUNCT punct (comma_Conj : Conj[14]) 1
                    [16] or 16 (15) CCONJ cc (or_Conj : Conj[16]) 1
                    *[17] ] 17 (16) PUNCT punct (StrComma "]" : Comma[17]) 1
                    [18] any 18 (17) DET det (anyPl_Det : Det[18]) 1
                    *[23,25,27,28,29,30,31,32,33] secrecy 23 (22) VERB acl (CN2_ (UseN secrecy_N) (AndCNPair_ or_Conj (AdjCN (PositA other_A) (AdvCN (UseN restriction_N) (PrepNP on_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN disclosure_N)) (PrepNP of_Prep (MassNP_sg (UseN information_N)))))))) : CN[23,25,27,28,29,30,31,32,33]) 1
                        *[20] , 20 (19) PUNCT punct (comma_Conj : Conj[20]) 1
                        *[21] as 21 (20) SCONJ mark (as_Subj : Subj[21]) 1
                        *[22] to 22 (21) PART mark (root_only (rootAdv_ to_Adv) : UDS[22]) 1
                        [25,27,28,29,30,31,32,33] restriction 28 (27) NOUN conj (AndCNPair_ or_Conj (AdjCN (PositA other_A) (AdvCN (UseN restriction_N) (PrepNP on_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN disclosure_N)) (PrepNP of_Prep (MassNP_sg (UseN information_N))))))) : Pair_Conj_CN[25,27,28,29,30,31,32,33]) 1
                            *[24] [ 24 (23) PUNCT punct (StrComma "[" : Comma[24]) 1
                            [25] or 25 (24) CCONJ cc (or_Conj : Conj[25]) 1
                                *[26] ] 26 (25) PUNCT punct (StrComma "]" : Comma[26]) 1
                            [27] other 27 (26) ADJ amod (PositA other_A : AP[27]) 1
                            [29,30,31,32,33] disclosure 31 (30) NOUN nmod (PrepNP on_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN disclosure_N)) (PrepNP of_Prep (MassNP_sg (UseN information_N)))) : Adv[29,30,31,32,33]) 1
                                [29] on 29 (28) ADP case (on_Prep : Prep[29]) 1
                                [30] the 30 (29) DET det (DetQuant DefArt NumSg : Det[30]) 1
                                [32,33] information 33 (32) NOUN nmod (PrepNP of_Prep (MassNP_sg (UseN information_N)) : Adv[32,33]) 1
                                    [32] of 32 (31) ADP case (of_Prep : Prep[32]) 1

# at, final GF tree, macros expanded:
root_nmod (rootN_ (MassNP (ConjCN or_Conj (BaseCN (UseN duty_N) (UseN obligation_N))))) (nmod_ under_Prep (DetCN anySg_Det (ConjCN or_Conj (BaseCN (AdjCN (PositA written_A) (UseN law_N)) (AdvCN (UseN rule_N) (PrepNP of_Prep (ConjNP or_Conj (BaseNP (MassNP (UseN law_N)) (DetCN anySg_Det (UseN contract_N))))))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is duty or obligation under any written law or rule of law or any contract

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_nmod (rootN_ (MassNP (ConjCN or_Conj (BaseCN (UseN duty_N) (UseN obligation_N))))) (nmod_ under_Prep (DetCN anySg_Det (ConjCN or_Conj (BaseCN (AdjCN (PositA written_A) (UseN law_N)) (AdvCN (UseN rule_N) (PrepNP of_Prep (ConjNP or_Conj (BaseNP (MassNP (UseN law_N)) (DetCN anySg_Det (UseN contract_N))))))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is duty or obligation under any written law or rule of law or any contract

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = rule of professional conduct applicable to [ the ] organisation
1	rule	rule	NOUN	SG-NOM	Number=Sing	0	root	_	_
2	of	of	ADP	_	_	4	case	_	_
3	professional	professional	ADJ	POS	Degree=Pos	4	amod	_	_
4	conduct	conduct	NOUN	SG-NOM	Number=Sing	1	nmod	_	_
5	applicable	applicable	ADJ	POS	Degree=Pos	4	amod	_	_
6	to	to	ADP	_	_	10	case	_	_
7	[	[	PUNCT	Period	_	10	punct	_	_
8	the	the	DET	DEF	Definite=Def|PronType=Art	10	det	_	_
9	]	]	PUNCT	Period	_	8	punct	_	_
10	organisation	organisation	NOUN	SG-NOM	Number=Sing	5	nmod	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1,2,3,4,5] rule 1 (2) NOUN root (root_nmod (rootN_ (MassNP_sg (UseN rule_N))) (nmod_ of_Prep (MassNP_sg (AdjCN (PositA applicable_A) (AdjCN (PositA professional_A) (UseN conduct_N))))) : UDS[1,2,3,4,5]) 1
    [2,3,4,5] conduct 4 (3) NOUN nmod (nmod_ of_Prep (MassNP_sg (AdjCN (PositA applicable_A) (AdjCN (PositA professional_A) (UseN conduct_N)))) : nmod[2,3,4,5]) 1
        [2] of 2 (1) ADP case (of_Prep : Prep[2]) 1
        [3] professional 3 (2) ADJ amod (PositA professional_A : AP[3]) 1
        [5,6,8,10] applicable 5 (4) ADJ amod (PositA applicable_A : AP[5]) 1
            *[6,7,8,10] organisation 10 (9) NOUN nmod (root_only (rootAdv_ (PrepNP to_Prep (DetCN (DetQuant DefArt NumSg) (UseN organization_N)))) : UDS[6,8,10]) 1
                [6] to 6 (5) ADP case (to_Prep : Prep[6]) 1
                *[7] [ 7 (6) PUNCT punct (StrComma "[" : Comma[7]) 1
                [8,9] the 8 (7) DET det (DetQuant DefArt NumSg : Det[8]) 1
                    *[9] ] 9 (8) PUNCT punct (StrComma "]" : Comma[9]) 1

# at, final GF tree, macros expanded:
root_nmod (rootN_ (MassNP (UseN rule_N))) (nmod_ of_Prep (MassNP (AdjCN (PositA applicable_A) (AdjCN (PositA professional_A) (UseN conduct_N)))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is rule of applicable professional conduct

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_nmod (rootN_ (MassNP (UseN rule_N))) (nmod_ of_Prep (MassNP (AdjCN (PositA applicable_A) (AdjCN (PositA professional_A) (UseN conduct_N)))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is rule of applicable professional conduct

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = [ apply concurrently ] with any obligation of the organisation under any other written law to notify any other person ( including any public agency ) of the occurrence of a data breach , or to provide any information relating to a data breach
1	[	[	PUNCT	Period	_	3	punct	_	_
2	apply	app	ADV	_	_	3	advmod	_	_
3	concurrently	concurrently	ADV	_	_	0	root	_	_
4	]	]	PUNCT	Period	_	3	punct	_	_
5	with	with	ADP	_	_	7	case	_	_
6	any	any	DET	IND	_	7	det	_	_
7	obligation	obligation	NOUN	SG-NOM	Number=Sing	3	nmod	_	_
8	of	of	ADP	_	_	10	case	_	_
9	the	the	DET	DEF	Definite=Def|PronType=Art	10	det	_	_
10	organisation	organisation	NOUN	SG-NOM	Number=Sing	7	nmod	_	_
11	under	under	ADP	_	_	15	case	_	_
12	any	any	DET	IND	_	15	det	_	_
13	other	other	ADJ	POS	Degree=Pos	15	amod	_	_
14	written	write	ADJ	PASS	Case=Nom	15	amod	_	_
15	law	law	NOUN	SG-NOM	Number=Sing	10	nmod	_	_
16	to	to	PART	_	_	17	mark	_	_
17	notify	notify	VERB	INF	VerbForm=Inf	15	acl	_	_
18	any	any	DET	IND	_	20	det	_	_
19	other	other	ADJ	POS	Degree=Pos	20	amod	_	_
20	person	person	NOUN	SG-NOM	Number=Sing	17	obj	_	_
21	(	(	PUNCT	LeftParenthesis	_	22	punct	_	_
22	including	include	VERB	ING	Tense=Pres|VerbForm=Part	20	acl	_	_
23	any	any	DET	IND	_	25	det	_	_
24	public	public	ADJ	POS	Degree=Pos	25	amod	_	_
25	agency	agency	NOUN	SG-NOM	Number=Sing	22	obj	_	_
26	)	)	PUNCT	RightParenthesis	_	22	punct	_	_
27	of	of	ADP	_	_	29	case	_	_
28	the	the	DET	DEF	Definite=Def|PronType=Art	29	det	_	_
29	occurrence	occurrence	NOUN	SG-NOM	Number=Sing	22	obl	_	_
30	of	of	ADP	_	_	33	case	_	_
31	a	a	DET	IND-SG	Definite=Ind|PronType=Art	33	det	_	_
32	data	data	NOUN	PL-NOM	Number=Sing	33	compound	_	_
33	breach	breach	NOUN	SG-NOM	Number=Sing	29	nmod	_	_
34	,	,	PUNCT	Comma	_	22	punct	_	_
35	or	or	CCONJ	_	_	37	cc	_	_
36	to	to	PART	_	_	37	mark	_	_
37	provide	provide	VERB	INF	VerbForm=Inf	22	conj	_	_
38	any	any	DET	IND	_	39	det	_	_
39	information	information	NOUN	SG-NOM	Number=Sing	37	obj	_	_
40	relating	relate	VERB	ING	Tense=Pres|VerbForm=Part	37	advcl	_	_
41	to	to	ADP	_	_	44	case	_	_
42	a	a	DET	IND-SG	Definite=Ind|PronType=Art	44	det	_	_
43	data	data	NOUN	PL-NOM	Number=Sing	44	compound	_	_
44	breach	breach	NOUN	SG-NOM	Number=Sing	40	obl	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[3,5,6,7,8,9,10,11,12,13,14,15] concurrently 3 (2) ADV root (root_nmod (rootAdv_ (PositAdvAdj concurrent_A)) (nmod_ with_Prep (DetCN_anySg anyPl_Det (AdvCN (UseN obligation_N) (PrepNP of_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN organization_N)) (PrepNP under_Prep (DetCN_anySg anyPl_Det (AdjCN (PositA written_A) (AdjCN (PositA other_A) (UseN law_N)))))))))) : UDS[3,5,6,7,8,9,10,11,12,13,14,15]) 1
    *[1] [ 1 (2) PUNCT punct (StrComma "[" : Comma[1]) 1
    *[2] apply 2 (1) ADV advmod (root_only (rootV_ (UseV apply_V)) : UDS[2]) 1
    *[4] ] 4 (3) PUNCT punct (StrComma "]" : Comma[4]) 1
    [5,6,7,8,9,10,11,12,13,14,15] obligation 7 (6) NOUN nmod (nmod_ with_Prep (DetCN_anySg anyPl_Det (AdvCN (UseN obligation_N) (PrepNP of_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN organization_N)) (PrepNP under_Prep (DetCN_anySg anyPl_Det (AdjCN (PositA written_A) (AdjCN (PositA other_A) (UseN law_N))))))))) : nmod[5,6,7,8,9,10,11,12,13,14,15]) 1
        [5] with 5 (4) ADP case (with_Prep : Prep[5]) 1
        [6] any 6 (5) DET det (anyPl_Det : Det[6]) 1
        [8,9,10,11,12,13,14,15] organisation 10 (9) NOUN nmod (PrepNP of_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN organization_N)) (PrepNP under_Prep (DetCN_anySg anyPl_Det (AdjCN (PositA written_A) (AdjCN (PositA other_A) (UseN law_N)))))) : Adv[8,9,10,11,12,13,14,15]) 1
            [8] of 8 (7) ADP case (of_Prep : Prep[8]) 1
            [9] the 9 (8) DET det (DetQuant DefArt NumSg : Det[9]) 1
            [11,12,13,14,15,17,18,19,20] law 15 (14) NOUN nmod (PrepNP under_Prep (DetCN_anySg anyPl_Det (AdjCN (PositA written_A) (AdjCN (PositA other_A) (UseN law_N)))) : Adv[11,12,13,14,15]) 1
                [11] under 11 (10) ADP case (under_Prep : Prep[11]) 1
                [12] any 12 (11) DET det (anyPl_Det : Det[12]) 1
                [13] other 13 (12) ADJ amod (PositA other_A : AP[13]) 1
                [14] written 14 (13) ADJ amod (PositA written_A : AP[14]) 1
                *[17,18,19,20] notify 17 (16) VERB acl (root_obj (rootV_ (UseV notify_V)) (obj_ (DetCN_anySg anyPl_Det (AdjCN (PositA other_A) (UseN person_N)))) : UDS[17,18,19,20]) 1
                    *[16] to 16 (15) PART mark (root_only (rootAdv_ to_Adv) : UDS[16]) 1
                    [18,19,20,22,23,24,25,27,28,29,30,31,32,33] person 20 (19) NOUN obj (obj_ (DetCN_anySg anyPl_Det (AdjCN (PositA other_A) (UseN person_N))) : obj[18,19,20]) 1
                        [18] any 18 (17) DET det (anyPl_Det : Det[18]) 1
                        [19] other 19 (18) ADJ amod (PositA other_A : AP[19]) 1
                        *[22,23,24,25,27,28,29,30,31,32,33] including 22 (21) VERB acl (root_obl (rootV_ (ComplV include_V (DetCN_anySg anyPl_Det (AdjCN (PositA public_A) (UseN agency_N))))) (obl_ (PrepNP of_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN occurrence_N)) (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN data_N breach_N))))))) : UDS[22,23,24,25,27,28,29,30,31,32,33]) 1
                            *[21] ( 21 (20) PUNCT punct (StrComma "(" : Comma[21]) 1
                            [23,24,25] agency 25 (24) NOUN obj (DetCN_anySg anyPl_Det (AdjCN (PositA public_A) (UseN agency_N)) : NP[23,24,25]) 1
                                [23] any 23 (22) DET det (anyPl_Det : Det[23]) 1
                                [24] public 24 (23) ADJ amod (PositA public_A : AP[24]) 1
                            *[26] ) 26 (25) PUNCT punct (StrComma ")" : Comma[26]) 1
                            [27,28,29,30,31,32,33] occurrence 29 (28) NOUN obl (obl_ (PrepNP of_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN occurrence_N)) (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN data_N breach_N)))))) : obl[27,28,29,30,31,32,33]) 1
                                [27] of 27 (26) ADP case (of_Prep : Prep[27]) 1
                                [28] the 28 (27) DET det (DetQuant DefArt NumSg : Det[28]) 1
                                [30,31,32,33] breach 33 (32) NOUN nmod (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN data_N breach_N))) : Adv[30,31,32,33]) 1
                                    [30] of 30 (29) ADP case (of_Prep : Prep[30]) 1
                                    [31] a 31 (30) DET det (DetQuant IndefArt NumSg : Det[31]) 1
                                    [32] data 32 (31) NOUN compound (data_N : N[32]) 1
                            *[34] , 34 (33) PUNCT punct (comma_Conj : Conj[34]) 1
                            *[37,38,39,40,41,42,43,44] provide 37 (36) VERB conj (root_advcl (rootV_ (ComplV provide_V (DetCN_anySg anyPl_Det (UseN information_N)))) (advclUDS_ (root_obl (rootV_ (UseV relate_V)) (obl_ (PrepNP to_Prep (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN data_N breach_N))))))) : UDS[37,38,39,40,41,42,43,44]) 1
                                *[35] or 35 (34) CCONJ cc (or_Conj : Conj[35]) 1
                                *[36] to 36 (35) PART mark (root_only (rootAdv_ to_Adv) : UDS[36]) 1
                                [38,39] information 39 (38) NOUN obj (DetCN_anySg anyPl_Det (UseN information_N) : NP[38,39]) 1
                                    [38] any 38 (37) DET det (anyPl_Det : Det[38]) 1
                                [40,41,42,43,44] relating 40 (39) VERB advcl (advclUDS_ (root_obl (rootV_ (UseV relate_V)) (obl_ (PrepNP to_Prep (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN data_N breach_N)))))) : advcl[40,41,42,43,44]) 1
                                    [41,42,43,44] breach 44 (43) NOUN obl (obl_ (PrepNP to_Prep (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN data_N breach_N)))) : obl[41,42,43,44]) 1
                                        [41] to 41 (40) ADP case (to_Prep : Prep[41]) 1
                                        [42] a 42 (41) DET det (DetQuant IndefArt NumSg : Det[42]) 1
                                        [43] data 43 (42) NOUN compound (data_N : N[43]) 1

# at, final GF tree, macros expanded:
root_nmod (rootAdv_ (PositAdvAdj concurrent_A)) (nmod_ with_Prep (DetCN anySg_Det (AdvCN (UseN obligation_N) (PrepNP of_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN organization_N)) (PrepNP under_Prep (DetCN anySg_Det (AdjCN (PositA written_A) (AdjCN (PositA other_A) (UseN law_N))))))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is concurrently with any obligation of the organization under any written other law

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_nmod (rootAdv_ (PositAdvAdj concurrent_A)) (nmod_ with_Prep (DetCN anySg_Det (AdvCN (UseN obligation_N) (PrepNP of_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN organization_N)) (PrepNP under_Prep (DetCN anySg_Det (AdjCN (PositA written_A) (AdjCN (PositA other_A) (UseN law_N))))))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is concurrently with any obligation of the organization under any written other law

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = organisation
1	organisation	organisation	NOUN	SG-NOM	Number=Sing	0	root	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[1] organisation 1 (2) NOUN root (root_only (rootN_ (MassNP_sg (UseN organization_N))) : UDS[1]) 1

# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN organization_N)))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is organization

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_only (rootN_ (MassNP (UseN organization_N)))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is organization

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = is a data intermediary processing personal data on behalf of and for the purposes of a public agency
1	is	be	AUX	PRES	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	4	cop	_	_
2	a	a	DET	IND-SG	Definite=Ind|PronType=Art	4	det	_	_
3	data	data	NOUN	PL-NOM	Number=Sing	4	compound	_	_
4	intermediary	intermediary	NOUN	SG-NOM	Number=Sing	0	root	_	_
5	processing	process	VERB	ING	Tense=Pres|VerbForm=Part	4	acl	_	_
6	personal	personal	ADJ	POS	Degree=Pos	7	amod	_	_
7	data	data	NOUN	PL-NOM	Number=Sing	5	obj	_	_
8	on	on	ADP	_	_	9	case	_	_
9	behalf	behalf	NOUN	SG-NOM	Number=Sing	5	obl	_	_
10	of	of	ADP	_	_	11	case	_	_
11	and	and	CCONJ	_	_	14	cc	_	_
12	for	for	ADP	_	_	14	case	_	_
13	the	the	DET	DEF	Definite=Def|PronType=Art	14	det	_	_
14	purposes	purpose	NOUN	PL-NOM	Number=Plur	9	conj	_	_
15	of	of	ADP	_	_	18	case	_	_
16	a	a	DET	IND-SG	Definite=Ind|PronType=Art	18	det	_	_
17	public	public	ADJ	POS	Degree=Pos	18	amod	_	_
18	agency	agency	NOUN	SG-NOM	Number=Sing	14	nmod	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18] intermediary 4 (3) NOUN root (root_acl (rootN_ (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN data_N intermediary_N)))) (aclUDSgerund_ (root_obl (rootV_ (ComplV process_V (MassNP_sg (AdjCN (PositA personal_A) (UseN data_N))))) (obl_ (Adv2_ (PrepNP on_Prep (MassNP_sg (UseN behalf_N))) (AndAdvPair_ and_Conj (PrepNP for_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN purpose_N)) (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA public_A) (UseN agency_N))))))))))) : UDS[2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18]) 1
    *[1] is 1 (2) AUX cop (be_aux : aux[1]) 1
    [2] a 2 (1) DET det (DetQuant IndefArt NumSg : Det[2]) 1
    [3] data 3 (2) NOUN compound (UseN data_N : CN[3]) 1
    [5,6,7,8,9,11,12,13,14,15,16,17,18] processing 5 (4) VERB acl (aclUDSgerund_ (root_obl (rootV_ (ComplV process_V (MassNP_sg (AdjCN (PositA personal_A) (UseN data_N))))) (obl_ (Adv2_ (PrepNP on_Prep (MassNP_sg (UseN behalf_N))) (AndAdvPair_ and_Conj (PrepNP for_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN purpose_N)) (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA public_A) (UseN agency_N)))))))))) : acl[5,6,7,8,9,11,12,13,14,15,16,17,18]) 1
        [6,7] data 7 (6) NOUN obj (MassNP_sg (AdjCN (PositA personal_A) (UseN data_N)) : NP[6,7]) 1
            [6] personal 6 (5) ADJ amod (PositA personal_A : AP[6]) 1
        [8,9,11,12,13,14,15,16,17,18] behalf 9 (8) NOUN obl (obl_ (Adv2_ (PrepNP on_Prep (MassNP_sg (UseN behalf_N))) (AndAdvPair_ and_Conj (PrepNP for_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN purpose_N)) (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA public_A) (UseN agency_N)))))))) : obl[8,9,11,12,13,14,15,16,17,18]) 1
            [8] on 8 (7) ADP case (on_Prep : Prep[8]) 1
            [11,12,13,14,15,16,17,18] purposes 14 (13) NOUN conj (AndAdvPair_ and_Conj (PrepNP for_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN purpose_N)) (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA public_A) (UseN agency_N)))))) : Pair_Conj_Adv[11,12,13,14,15,16,17,18]) 1
                [11] and 11 (10) CCONJ cc (and_Conj : Conj[11]) 1
                    *[10] of 10 (9) ADP case (PrepListHead_ of_Prep : PrefixPrep[10]) 1
                [12] for 12 (11) ADP case (for_Prep : Prep[12]) 1
                [13] the 13 (12) DET det (DetQuant DefArt NumSg : Det[13]) 1
                [15,16,17,18] agency 18 (17) NOUN nmod (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA public_A) (UseN agency_N))) : Adv[15,16,17,18]) 1
                    [15] of 15 (14) ADP case (of_Prep : Prep[15]) 1
                    [16] a 16 (15) DET det (DetQuant IndefArt NumSg : Det[16]) 1
                    [17] public 17 (16) ADJ amod (PositA public_A : AP[17]) 1

# at, final GF tree, macros expanded:
root_acl (rootN_ (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN data_N intermediary_N)))) (aclUDSgerund_ (root_obl (rootV_ (ComplV process_V (MassNP (AdjCN (PositA personal_A) (UseN data_N))))) (obl_ (ConjAdv and_Conj (BaseAdv (PrepNP on_Prep (MassNP (UseN behalf_N))) (PrepNP for_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN purpose_N)) (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA public_A) (UseN agency_N)))))))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is a data intermediary that processes personal data on behalf and for the purpose of a public agency

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_acl (rootN_ (DetCN (DetQuant IndefArt NumSg) (UseN (CompoundN data_N intermediary_N)))) (aclUDSgerund_ (root_obl (rootV_ (ComplV process_V (MassNP (AdjCN (PositA personal_A) (UseN data_N))))) (obl_ (ConjAdv and_Conj (BaseAdv (PrepNP on_Prep (MassNP (UseN behalf_N))) (PrepNP for_Prep (AdvNP (DetCN (DetQuant DefArt NumSg) (UseN purpose_N)) (PrepNP of_Prep (DetCN (DetQuant IndefArt NumSg) (AdjCN (PositA public_A) (UseN agency_N)))))))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is a data intermediary that processes personal data on behalf and for the purpose of a public agency

# ud, UD tree in CoNLLU format:
# newdoc
# newpar
# sent_id = 1
# text = has reason to believe that [ a ] data breach has occurred in relation to that personal data
1	has	have	AUX	PRES-AUX	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	2	aux	_	_
2	reason	reason	NOUN	SG-NOM	Number=Sing	0	root	_	_
3	to	to	PART	_	_	4	mark	_	_
4	believe	believe	VERB	INF	VerbForm=Inf	2	acl	_	_
5	that	that	PRON	DEM-SG	Number=Sing|PronType=Dem	4	obj	_	_
6	[	[	PUNCT	Period	_	12	punct	_	_
7	a	a	DET	IND-SG	Definite=Ind|PronType=Art	12	det	_	_
8	]	]	PUNCT	Period	_	12	punct	_	_
9	data	data	NOUN	PL-NOM	Number=Sing	10	compound	_	_
10	breach	breach	NOUN	SG-NOM	Number=Sing	12	nsubj:pass	_	_
11	has	have	AUX	PRES-AUX	Mood=Ind|Number=Sing|Person=3|Tense=Pres|VerbForm=Fin	12	aux:pass	_	_
12	occurred	occur	VERB	PASS	Tense=Past|VerbForm=Part|Voice=Pass	4	advcl	_	_
13	in	in	ADP	_	_	14	case	_	_
14	relation	relation	NOUN	SG-NOM	Number=Sing	12	obl	_	_
15	to	to	ADP	_	_	18	case	_	_
16	that	that	DET	DEM-SG	Number=Sing|PronType=Dem	18	det	_	_
17	personal	personal	ADJ	POS	Degree=Pos	18	amod	_	_
18	data	data	NOUN	PL-NOM	Number=Sing	12	obl	_	SpacesAfter=\n

# bt0, the best (most complete) tree, without backups:
[2,4,5,12,13,14,15,16,17,18] reason 2 (1) NOUN root (root_acl (rootN_ (MassNP_sg (UseN reason_N))) (aclUDSgerund_ (root_advcl (rootV_ (ComplV believe_V (DetNP (DetQuant that_Quant NumSg)))) (advclUDS_ (root_obl_obl (rootV_ (PassV_ occur_V)) (obl_ (PrepNP in_Prep (MassNP_sg (UseN relation_N)))) (obl_ (PrepNP to_Prep (DetCN (DetQuant that_Quant NumSg) (AdjCN (PositA personal_A) (UseN data_N))))))))) : UDS[2,4,5,12,13,14,15,16,17,18]) 1
    *[1] has 1 (2) AUX aux (have_aux : aux[1]) 1
    [4,5,12,13,14,15,16,17,18] believe 4 (3) VERB acl (aclUDSgerund_ (root_advcl (rootV_ (ComplV believe_V (DetNP (DetQuant that_Quant NumSg)))) (advclUDS_ (root_obl_obl (rootV_ (PassV_ occur_V)) (obl_ (PrepNP in_Prep (MassNP_sg (UseN relation_N)))) (obl_ (PrepNP to_Prep (DetCN (DetQuant that_Quant NumSg) (AdjCN (PositA personal_A) (UseN data_N)))))))) : acl[4,5,12,13,14,15,16,17,18]) 1
        *[3] to 3 (2) PART mark (root_only (rootAdv_ to_Adv) : UDS[3]) 1
        [5] that 5 (4) PRON obj (DetNP (DetQuant that_Quant NumSg) : NP[5]) 1
        [12,13,14,15,16,17,18] occurred 12 (11) VERB advcl (advclUDS_ (root_obl_obl (rootV_ (PassV_ occur_V)) (obl_ (PrepNP in_Prep (MassNP_sg (UseN relation_N)))) (obl_ (PrepNP to_Prep (DetCN (DetQuant that_Quant NumSg) (AdjCN (PositA personal_A) (UseN data_N)))))) : advcl[12,13,14,15,16,17,18]) 1
            *[6] [ 6 (5) PUNCT punct (StrComma "[" : Comma[6]) 1
            *[7] a 7 (6) DET det (root_only (rootDet_ (DetQuant IndefArt NumSg)) : UDS[7]) 1
            *[8] ] 8 (7) PUNCT punct (StrComma "]" : Comma[8]) 1
            *[9,10] breach 10 (9) NOUN nsubj:pass (root_only (rootN_ (MassNP_sg (UseN (CompoundN data_N breach_N)))) : UDS[9,10]) 1
                [9] data 9 (8) NOUN compound (data_N : N[9]) 1
            *[11] has 11 (10) AUX aux:pass (have_aux : aux[11]) 1
            [13,14] relation 14 (13) NOUN obl (obl_ (PrepNP in_Prep (MassNP_sg (UseN relation_N))) : obl[13,14]) 1
                [13] in 13 (12) ADP case (in_Prep : Prep[13]) 1
            [15,16,17,18] data 18 (17) NOUN obl (obl_ (PrepNP to_Prep (DetCN (DetQuant that_Quant NumSg) (AdjCN (PositA personal_A) (UseN data_N)))) : obl[15,16,17,18]) 1
                [15] to 15 (14) ADP case (to_Prep : Prep[15]) 1
                [16] that 16 (15) DET det (DetQuant that_Quant NumSg : Det[16]) 1
                [17] personal 17 (16) ADJ amod (PositA personal_A : AP[17]) 1

# at, final GF tree, macros expanded:
root_acl (rootN_ (MassNP (UseN reason_N))) (aclUDSgerund_ (root_advcl (rootV_ (ComplV believe_V (DetNP (DetQuant that_Quant NumSg)))) (advclUDS_ (root_obl_obl (rootV_ (PassV occur_V)) (obl_ (PrepNP in_Prep (MassNP (UseN relation_N)))) (obl_ (PrepNP to_Prep (DetCN (DetQuant that_Quant NumSg) (AdjCN (PositA personal_A) (UseN data_N)))))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
LIN: is reason that believes that is occurred in relation to that personal data

#sum, an extractive summary (tree built from interpreted nodes)
# at, final GF tree, macros expanded:
root_acl (rootN_ (MassNP (UseN reason_N))) (aclUDSgerund_ (root_advcl (rootV_ (ComplV believe_V (DetNP (DetQuant that_Quant NumSg)))) (advclUDS_ (root_obl_obl (rootV_ (PassV occur_V)) (obl_ (PrepNP in_Prep (MassNP (UseN relation_N)))) (obl_ (PrepNP to_Prep (DetCN (DetQuant that_Quant NumSg) (AdjCN (PositA personal_A) (UseN data_N)))))))))

# tc, type checking the final GF tree:
type checking OK


# lin, linearize tree using the active language of the environment:
SUMMARY LIN: is reason that believes that is occurred in relation to that personal data

# stat, show statistics of original and interpreted words:
total word nodes:	479
interpreted word nodes:	185 (38%)
unknown word nodes (tokens):	46 (9%)
total sentences:	34
completely interpreted sentences:	15 (44%)
type-correct sentences:	33 (97%)

